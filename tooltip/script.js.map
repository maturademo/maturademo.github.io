{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","tests/tooltip/script.js","script.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","nextIndex","data","accessor","item","index","this_d","next","afterThis","beforeNext","Δ1","Math","abs","Δ2","tooltip","parent","textAccessor","tip","d3","select","empty","append","attr","label","text","cord","format","time","xScale","scale","yScale","linear","w","h","graphTransform","xstart","ytop","xend","ybottom","transform","x","y","mouse","range","xAxis","svg","axis","orient","ticks","yAxis","csv","err","zoomed","xAxisContainer","yAxisContainer","event","translate","v","selectAll","d","Date","Mean","updateTooltip","x_date","invert","tooltipIndex","round","sort","b","parse","Open","parseFloat","Close","xWertebereich","min","max","ΔDate","getTime","yWertebereich","ΔMean","domain","zoom","behavior","scaleExtent","on","graph","enter","this"],"mappings":"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","file":"script.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Findet den zu einem gegebenen Wert den nächsten in einem Array vorhandenem Wert.\n * @param  {[Array]} data         Datenset\n * @param  {[Function]} accessor  Funktion, das den zu vergleichenden Wert\n *                                zurückgibt, wenn das Objekt gegeben wird.\n * @param  {[type]} item          Der zu vergleichende Wert\n * @return {[Number]}             Der Index (0 < @return < data.length-1)\n */\nfunction nextIndex(data, accessor, item){\n  var index = -1;\n  for(var i = 0; i<data.length-1; i++){\n    // Liegt der Punkt zwischen zwei gegebenen Punkten?\n    var this_d = accessor(data[i]);\n    var next = accessor(data[i+1]);\n    var afterThis = item >=this_d;\n    var beforeNext = item <= next;\n\n    if(afterThis && beforeNext){\n      // Falls ja, setze 'index' auf den index des näheren Punktes.\n      Δ1 = Math.abs(accessor(data[i]) - item);\n      Δ2 = Math.abs(accessor(data[i+1]) - item);\n      index = Δ1 < Δ2 ? i : i + 1;\n    }\n  }\n  return index;\n}\n/**\n * Funktion für den Tooltip-Kreis und die Werteanzeige\n * @param  {[Array]} data           Datenarray\n * @param  {[Function]} accessor    Funktion, die das Koordinatenpaar den Punktes\n *                                \tzurückgibt.\n * @param  {[Number]} index         Index des Datenarray, die den zu \"tooltippenden\"\n *                                \tWert entspricht.\n * @param {{d3 View}} parent        d3-View, in das das Tooltip eingesetzt werden\n *                    \t\t\t\t\t\t\tsollte.\n * @param {{Function}} textAccessor Funktion, die den Text für das Tooltip zu-\n *                                  rückgibt.\n */\nfunction tooltip(data, accessor, index, parent, textAccessor) {\n  // tooltip-Variablen\n\n  var tip = d3.select(\"#tooltip\");\n  if(tip.empty()){\n    tip = parent.append(\"g\")\n      .attr(\"id\", \"tooltip\")\n      .attr(\"class\", \"tooltip\");\n\n    tip.append(\"circle\")\n      .attr(\"id\", \"tooltip-circle\");\n\n    var label = tip.append(\"g\")\n      .attr(\"id\", \"label\");\n\n    var text = label.append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"id\", \"label-text\");\n  }\n\n  if(index==-1){\n    tip.attr(\"visibility\", \"hidden\");\n    return;\n  }\n  tip.attr(\"visibility\", \"visible\");\n\n\n  d3.select(\"#label-text\")\n    .text(textAccessor(data[index]))\n    .attr(\"x\", 0)\n    .attr(\"y\", -10);\n\n  var cord = accessor(data[index]);\n  tip.attr(\"transform\", \"translate(\"+cord[0]+\",\"+cord[1]+\")\");\n}\n\n// Bestimmen des Zeitformats der Daten (z. B. 2012-02-27)\nvar format = d3.time.format('%Y-%m-%d');\n\n// (Lineare) Skalierung der Achsen mit d3 bestimmen\nvar xScale = d3.time.scale();\nvar yScale = d3.scale.linear();\n\n// Höhe und Breite des gesamten SVG-Elements definieren; Verschiebung des\n// Graphs\nvar w = 850;\nvar h = 400;\nvar graphTransform = {xstart: 50, ytop: 0, xend:0, ybottom:50};\n\n// Global Zoomvariablen\nvar transform = {x:0,y:0};\nvar scale = 1;\n\nvar mouse = [];\n\n// Wertebereich der Achsenskalierungen definieren. Hier ist die Anzahl der Pixel\n// gemeint, über die sich die Achsen erstrecken. Die x-Achse und die y-Achse\n// verschieben wir um 50 nach rechts, damit man die y-Achse beschriften kann.\nxScale.range([0,w - graphTransform.xstart - graphTransform.xend]);\nyScale.range([h - graphTransform.ytop - graphTransform.ybottom, 0]);\n\n// Die Achsen werden von d3 generiert.\nvar xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\").ticks(5);\nvar yAxis = d3.svg.axis().scale(yScale).orient(\"left\").ticks(5);\n\n/**\n * Laden des Datensatzes durch d3, wird in den Array data geladen.\n * @param  {[String]} 'data.csv'            Pfad der csv-Datei\n * @param  {[Function]} function(err, data) callback-Funktion, mit Fehlerelement und\n *                                \t\t\t \t\tDatenarray\n */\nd3.csv('data.csv', function(err, data) {\n\n  // Sortieren, denn wir brauchen dies für unseren Tooltip-Algorithmus\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n  data.sort(function(a, b) {\n    if (a.Date<b.Date) {\n      return -1;\n    }\n    if (a.Date>b.Date) {\n      return 1;\n    }\n    return 0;\n  });\n\n  // Schleife, um die Einträge zu formatieren\n  for(var i = 0; i<data.length; i++) {\n    // Anwenden des Zeitformats: Konvertieren des Strings in ein Javascript-\n    // Datum.\n    data[i].Date = format.parse(data[i].Date);\n\n    // Konvertieren des String in eine Javascript-Zahl\n    data[i].Open = parseFloat(data[i].Open);\n    data[i].Close = parseFloat(data[i].Close);\n\n    // Berechnen des \"Durchschnittspreises\" für einen Tag\n    data[i].Mean = (data[i].Open + data[i].Close) / 2;\n  }\n\n  /**\n   *  Wertebereich der Daten bestimmen mit d3: Um einen kleinen Abstand zwischen\n   *  den maximalen Punkten und dem Ende des Rändern des Diagrammes zu bewahren,\n   *  wird der Unterschied (Δ) des Minimums und dem untersuchten Wert mit 1.1\n   *  mulitpliziert. Anschliessend wird die Summe des Minimums und des\n   *  multiplizierten Wertes an d3 zurückgegeben.\n   */\n  var xWertebereich = [];\n  xWertebereich[0] = d3.min(data, function(d) {\n    return d.Date;\n  });\n  xWertebereich[1] = d3.max(data, function(d) {\n    var ΔDate = d.Date.getTime() - xWertebereich[0].getTime();\n    ΔDate *= 1.1;\n    return new Date(ΔDate + xWertebereich[0].getTime());\n  });\n\n  var yWertebereich = [];\n  yWertebereich[0] = d3.min(data, function(d) {\n    return d.Mean;\n  });\n  yWertebereich[1] = d3.max(data, function(d) {\n    var ΔMean = d.Mean - yWertebereich[0];\n    return yWertebereich[0] + ΔMean * 1.1;\n  });\n\n  xScale.domain(xWertebereich);\n  yScale.domain(yWertebereich);\n\n  // Zoom hinzufügen, das durch d3 unterstützt wird\n  var zoom = d3.behavior.zoom()\n    .x(xScale)\n    .y(yScale)\n    .scaleExtent([1, 50])\n    .on(\"zoom\", zoomed);\n\n  // die variable graph initialiseren, damit sie in der Funktion zoomed() ver-\n  // wendet werden kann, obwohl sie erst später definiert wird.\n  var graph = null;\n\n  // Mit der Funktion 'zoomed' werden die x-Achse und die y-Achse aktualisiert\n  function zoomed() {\n    // Achsen neu zeichnen\n    xAxisContainer.call(xAxis);\n    yAxisContainer.call(yAxis);\n\n    // Den Graphen entsprechend anpassen:\n\n    // Methode 2: Zoomvariablen setzen und die Position die Punkte transformieren\n    transform.x = d3.event.translate[0];\n    transform.y = d3.event.translate[1];\n    scale = d3.event.scale;\n\n    // Punkte neu berechnen.\n    v.selectAll(\"circle.data-point\")\n      .attr(\"cx\", function(d) { return xScale(d.Date); })\n      .attr(\"cy\", function(d) { return yScale(d.Mean); });\n\n    // Tooltip bei Zoom auch aktualisieren\n    updateTooltip();\n  }\n\n  // SVG-Element mit id 'visualization' extrahieren\n  var v = d3.select(\"#visualization\")\n    .attr(\"width\", w)\n    .attr(\"height\", h)\n\n  // Unterstützung für Zoom hinzufügen (d3)\n    .call(zoom);\n\n  // SVG-Maske für den Graph: Wir wollen nicht, dass Punkte aus unserem\n  // definierten Feld auftauchen.\n  v.append(\"mask\")\n    .attr(\"id\", \"mask\")\n    .append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n      .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n      .attr(\"fill\", \"white\");\n\n  graph = v.append(\"g\")\n    .attr(\"id\", \"graph\")\n    .attr(\"transform\", \"translate(\" + graphTransform.xstart + \",\" + graphTransform.ytop + \")\")\n    .attr(\"mask\", \"url(#mask)\")\n    .selectAll(\"circle\")\n\n    // Die Daten zum Element mit der d3-Binding-Method binden: Die nach dem\n    // enter() stehenden Befehle werden für alle Elemente in dem Array\n    // ausgeführt.\n    .data(data).enter()\n    .append(\"circle\")\n      .attr(\"class\", \"data-point\")\n      //.attr(\"data-x-identifier\", function(d) { return d.Date; })\n      .attr(\"cx\", function(d) { return xScale(d.Date); })\n      .attr(\"cy\", function(d) { return yScale(d.Mean); });\n\n  // Achsen hinzufügen\n  var xAxisContainer = v.append(\"g\")\n    .attr(\"class\", \"axis axis-x\")\n    .attr(\"transform\", \"translate(\" +\n      graphTransform.xstart + \",\" +\n      (h - graphTransform.ybottom) + \")\")\n    .call(xAxis);\n\n  var yAxisContainer = v.append(\"g\")\n    .attr(\"class\", \"axis axis-y\")\n    .attr(\"transform\", \"translate(50,0)\")\n    .call(yAxis);\n\n  // Maus-Koordinaten: Um auf die Maus-Koordinaten zugreifen zu können, muss man\n  // ein unsichtbares Element über den gesamten Graph legen, der alle\n  // 'Maus-Events' \"aufnimmt\". Ein leerer g-SVG-Container (wie 'graph') ist\n  // nicht fähig, Maus-Events aufzunehmen.\n  v.append(\"rect\")\n    .attr(\"id\", \"overlay\")\n    .attr(\"x\", graphTransform.xstart)\n    .attr(\"y\", graphTransform.ytop)\n    .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n    .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n    .on(\"mousemove\", function() {\n      mouse = d3.mouse(this);\n      updateTooltip();\n    });\n\n\n  function updateTooltip() {\n    var cord = [];\n    cord[0] = mouse[0]-graphTransform.xstart;\n    cord[1] = mouse[1]-graphTransform.ytop;\n    // x|y-Werte berechnen\n    var x_date = xScale.invert(cord[0]);\n    //tooltip\n    var tooltipIndex = nextIndex(data, function(d){ return d.Date;}, x_date);\n\n    //tooltip\n    tooltip(data, function(d){\n      return [xScale(d.Date), yScale(d.Mean)];\n    }, tooltipIndex, d3.select(\"#graph\"), function(d) {\n      // Zahl runden\n      // http://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript\n      return Math.round(d.Mean * 1000) / 1000;\n    });\n\n  }\n});\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Findet den zu einem gegebenen Wert den nächsten in einem Array vorhandenem Wert.\n * @param  {[Array]} data         Datenset\n * @param  {[Function]} accessor  Funktion, das den zu vergleichenden Wert\n *                                zurückgibt, wenn das Objekt gegeben wird.\n * @param  {[type]} item          Der zu vergleichende Wert\n * @return {[Number]}             Der Index (0 < @return < data.length-1)\n */\nfunction nextIndex(data, accessor, item){\n  var index = -1;\n  for(var i = 0; i<data.length-1; i++){\n    // Liegt der Punkt zwischen zwei gegebenen Punkten?\n    var this_d = accessor(data[i]);\n    var next = accessor(data[i+1]);\n    var afterThis = item >=this_d;\n    var beforeNext = item <= next;\n\n    if(afterThis && beforeNext){\n      // Falls ja, setze 'index' auf den index des näheren Punktes.\n      Δ1 = Math.abs(accessor(data[i]) - item);\n      Δ2 = Math.abs(accessor(data[i+1]) - item);\n      index = Δ1 < Δ2 ? i : i + 1;\n    }\n  }\n  return index;\n}\n/**\n * Funktion für den Tooltip-Kreis und die Werteanzeige\n * @param  {[Array]} data           Datenarray\n * @param  {[Function]} accessor    Funktion, die das Koordinatenpaar den Punktes\n *                                \tzurückgibt.\n * @param  {[Number]} index         Index des Datenarray, die den zu \"tooltippenden\"\n *                                \tWert entspricht.\n * @param {{d3 View}} parent        d3-View, in das das Tooltip eingesetzt werden\n *                    \t\t\t\t\t\t\tsollte.\n * @param {{Function}} textAccessor Funktion, die den Text für das Tooltip zu-\n *                                  rückgibt.\n */\nfunction tooltip(data, accessor, index, parent, textAccessor) {\n  // tooltip-Variablen\n\n  var tip = d3.select(\"#tooltip\");\n  if(tip.empty()){\n    tip = parent.append(\"g\")\n      .attr(\"id\", \"tooltip\")\n      .attr(\"class\", \"tooltip\");\n\n    tip.append(\"circle\")\n      .attr(\"id\", \"tooltip-circle\");\n\n    var label = tip.append(\"g\")\n      .attr(\"id\", \"label\");\n\n    var text = label.append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"id\", \"label-text\");\n  }\n\n  if(index==-1){\n    tip.attr(\"visibility\", \"hidden\");\n    return;\n  }\n  tip.attr(\"visibility\", \"visible\");\n\n\n  d3.select(\"#label-text\")\n    .text(textAccessor(data[index]))\n    .attr(\"x\", 0)\n    .attr(\"y\", -10);\n\n  var cord = accessor(data[index]);\n  tip.attr(\"transform\", \"translate(\"+cord[0]+\",\"+cord[1]+\")\");\n}\n\n// Bestimmen des Zeitformats der Daten (z. B. 2012-02-27)\nvar format = d3.time.format('%Y-%m-%d');\n\n// (Lineare) Skalierung der Achsen mit d3 bestimmen\nvar xScale = d3.time.scale();\nvar yScale = d3.scale.linear();\n\n// Höhe und Breite des gesamten SVG-Elements definieren; Verschiebung des\n// Graphs\nvar w = 850;\nvar h = 400;\nvar graphTransform = {xstart: 50, ytop: 0, xend:0, ybottom:50};\n\n// Global Zoomvariablen\nvar transform = {x:0,y:0};\nvar scale = 1;\n\nvar mouse = [];\n\n// Wertebereich der Achsenskalierungen definieren. Hier ist die Anzahl der Pixel\n// gemeint, über die sich die Achsen erstrecken. Die x-Achse und die y-Achse\n// verschieben wir um 50 nach rechts, damit man die y-Achse beschriften kann.\nxScale.range([0,w - graphTransform.xstart - graphTransform.xend]);\nyScale.range([h - graphTransform.ytop - graphTransform.ybottom, 0]);\n\n// Die Achsen werden von d3 generiert.\nvar xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\").ticks(5);\nvar yAxis = d3.svg.axis().scale(yScale).orient(\"left\").ticks(5);\n\n/**\n * Laden des Datensatzes durch d3, wird in den Array data geladen.\n * @param  {[String]} 'data.csv'            Pfad der csv-Datei\n * @param  {[Function]} function(err, data) callback-Funktion, mit Fehlerelement und\n *                                \t\t\t \t\tDatenarray\n */\nd3.csv('data.csv', function(err, data) {\n\n  // Sortieren, denn wir brauchen dies für unseren Tooltip-Algorithmus\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n  data.sort(function(a, b) {\n    if (a.Date<b.Date) {\n      return -1;\n    }\n    if (a.Date>b.Date) {\n      return 1;\n    }\n    return 0;\n  });\n\n  // Schleife, um die Einträge zu formatieren\n  for(var i = 0; i<data.length; i++) {\n    // Anwenden des Zeitformats: Konvertieren des Strings in ein Javascript-\n    // Datum.\n    data[i].Date = format.parse(data[i].Date);\n\n    // Konvertieren des String in eine Javascript-Zahl\n    data[i].Open = parseFloat(data[i].Open);\n    data[i].Close = parseFloat(data[i].Close);\n\n    // Berechnen des \"Durchschnittspreises\" für einen Tag\n    data[i].Mean = (data[i].Open + data[i].Close) / 2;\n  }\n\n  /**\n   *  Wertebereich der Daten bestimmen mit d3: Um einen kleinen Abstand zwischen\n   *  den maximalen Punkten und dem Ende des Rändern des Diagrammes zu bewahren,\n   *  wird der Unterschied (Δ) des Minimums und dem untersuchten Wert mit 1.1\n   *  mulitpliziert. Anschliessend wird die Summe des Minimums und des\n   *  multiplizierten Wertes an d3 zurückgegeben.\n   */\n  var xWertebereich = [];\n  xWertebereich[0] = d3.min(data, function(d) {\n    return d.Date;\n  });\n  xWertebereich[1] = d3.max(data, function(d) {\n    var ΔDate = d.Date.getTime() - xWertebereich[0].getTime();\n    ΔDate *= 1.1;\n    return new Date(ΔDate + xWertebereich[0].getTime());\n  });\n\n  var yWertebereich = [];\n  yWertebereich[0] = d3.min(data, function(d) {\n    return d.Mean;\n  });\n  yWertebereich[1] = d3.max(data, function(d) {\n    var ΔMean = d.Mean - yWertebereich[0];\n    return yWertebereich[0] + ΔMean * 1.1;\n  });\n\n  xScale.domain(xWertebereich);\n  yScale.domain(yWertebereich);\n\n  // Zoom hinzufügen, das durch d3 unterstützt wird\n  var zoom = d3.behavior.zoom()\n    .x(xScale)\n    .y(yScale)\n    .scaleExtent([1, 50])\n    .on(\"zoom\", zoomed);\n\n  // die variable graph initialiseren, damit sie in der Funktion zoomed() ver-\n  // wendet werden kann, obwohl sie erst später definiert wird.\n  var graph = null;\n\n  // Mit der Funktion 'zoomed' werden die x-Achse und die y-Achse aktualisiert\n  function zoomed() {\n    // Achsen neu zeichnen\n    xAxisContainer.call(xAxis);\n    yAxisContainer.call(yAxis);\n\n    // Den Graphen entsprechend anpassen:\n\n    // Methode 2: Zoomvariablen setzen und die Position die Punkte transformieren\n    transform.x = d3.event.translate[0];\n    transform.y = d3.event.translate[1];\n    scale = d3.event.scale;\n\n    // Punkte neu berechnen.\n    v.selectAll(\"circle.data-point\")\n      .attr(\"cx\", function(d) { return xScale(d.Date); })\n      .attr(\"cy\", function(d) { return yScale(d.Mean); });\n\n    // Tooltip bei Zoom auch aktualisieren\n    updateTooltip();\n  }\n\n  // SVG-Element mit id 'visualization' extrahieren\n  var v = d3.select(\"#visualization\")\n    .attr(\"width\", w)\n    .attr(\"height\", h)\n\n  // Unterstützung für Zoom hinzufügen (d3)\n    .call(zoom);\n\n  // SVG-Maske für den Graph: Wir wollen nicht, dass Punkte aus unserem\n  // definierten Feld auftauchen.\n  v.append(\"mask\")\n    .attr(\"id\", \"mask\")\n    .append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n      .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n      .attr(\"fill\", \"white\");\n\n  graph = v.append(\"g\")\n    .attr(\"id\", \"graph\")\n    .attr(\"transform\", \"translate(\" + graphTransform.xstart + \",\" + graphTransform.ytop + \")\")\n    .attr(\"mask\", \"url(#mask)\")\n    .selectAll(\"circle\")\n\n    // Die Daten zum Element mit der d3-Binding-Method binden: Die nach dem\n    // enter() stehenden Befehle werden für alle Elemente in dem Array\n    // ausgeführt.\n    .data(data).enter()\n    .append(\"circle\")\n      .attr(\"class\", \"data-point\")\n      //.attr(\"data-x-identifier\", function(d) { return d.Date; })\n      .attr(\"cx\", function(d) { return xScale(d.Date); })\n      .attr(\"cy\", function(d) { return yScale(d.Mean); });\n\n  // Achsen hinzufügen\n  var xAxisContainer = v.append(\"g\")\n    .attr(\"class\", \"axis axis-x\")\n    .attr(\"transform\", \"translate(\" +\n      graphTransform.xstart + \",\" +\n      (h - graphTransform.ybottom) + \")\")\n    .call(xAxis);\n\n  var yAxisContainer = v.append(\"g\")\n    .attr(\"class\", \"axis axis-y\")\n    .attr(\"transform\", \"translate(50,0)\")\n    .call(yAxis);\n\n  // Maus-Koordinaten: Um auf die Maus-Koordinaten zugreifen zu können, muss man\n  // ein unsichtbares Element über den gesamten Graph legen, der alle\n  // 'Maus-Events' \"aufnimmt\". Ein leerer g-SVG-Container (wie 'graph') ist\n  // nicht fähig, Maus-Events aufzunehmen.\n  v.append(\"rect\")\n    .attr(\"id\", \"overlay\")\n    .attr(\"x\", graphTransform.xstart)\n    .attr(\"y\", graphTransform.ytop)\n    .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n    .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n    .on(\"mousemove\", function() {\n      mouse = d3.mouse(this);\n      updateTooltip();\n    });\n\n\n  function updateTooltip() {\n    var cord = [];\n    cord[0] = mouse[0]-graphTransform.xstart;\n    cord[1] = mouse[1]-graphTransform.ytop;\n    // x|y-Werte berechnen\n    var x_date = xScale.invert(cord[0]);\n    //tooltip\n    var tooltipIndex = nextIndex(data, function(d){ return d.Date;}, x_date);\n\n    //tooltip\n    tooltip(data, function(d){\n      return [xScale(d.Date), yScale(d.Mean)];\n    }, tooltipIndex, d3.select(\"#graph\"), function(d) {\n      // Zahl runden\n      // http://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript\n      return Math.round(d.Mean * 1000) / 1000;\n    });\n\n  }\n});\n\n},{}]},{},[1])\n\n"],"sourceRoot":"/source/"}