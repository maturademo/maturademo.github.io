{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","tests/dimensions/modules/domain.js","script.js","tests/dimensions/modules/filter.js","tests/dimensions/modules/format.js","tests/dimensions/modules/id.js","tests/dimensions/modules/range.js","tests/dimensions/modules/sort.js","tests/dimensions/script.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","range","overflowX","data","index","overflowFactor","xWertebereich","min","accessor","max","applyOverflow","data_type","overflowY","values","v_bundle","yWertebereich","minMultipleSets","maxMultipleSets","./range",2,"row","ret","push",3,"id","data_types","config","j","parseFloat","d3","time","format","date_format","parse","ids","type","get","./id","./sort",4,"url","invert","rowId","raw","attr",5,"activated","lmin","lmax","factor","Date","getTime",6,"sort","b",7,"loadFiles","mkcb","err","resp","alert","console","log","datasetsMeta","loaded","loadVisualization","csv","x_ac","ide","x_i","split","y_i","parseInt","y_ac","x_sc","sc","xScale","scale","linear","xD","domain","tileW","y_sc","tileH","drawLabel","zeile","spalte","name","v","append","classed","html","drawGraph","x","y","items","graphId","graph","circles","selectAll","enter","d","ac","select","w","h","spaltenAnzahl","buf","filter","graphConfArray","xConfig","data_tmp","copy","yConfig","data_to_merge","here","JSON","stringify","k","undefined","obj","c","unit","v_accessor","v_accessor_scaled","v_accessor_cord","yScale","json","res","datasets","colors","category20","dataset","color","accessor_scaled","entry","scaled","cord","./modules/domain","./modules/filter","./modules/format","./modules/id","./modules/range","./modules/sort"],"mappings":"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","file":"script.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var range = require('./range')\n\n/**\n * Modul: Domain\n * -------------\n * Gibt einen überhöhten Wertbereich zurück für x und y.\n * Überhöhte Wertebereiche werden hier benutzt, damit ein wenig Platz links und\n * oberhalb der Linie entsteht.\n */\n\n/**\n * Gibt überhöhten Wertebereich für x zurück.\n * @param  {[Array]} data             Gemergter Datensatz, ungefiltert\n * @param  {[Object]} index           Config-Objekt für die Index-Spalte\n * @param  {[Number]} overflowFactor  Überhöhungsfaktor\n * @return {[Array]}                  Das Minimum und Maximum in einem Array\n */\nmodule.exports.overflowX = function (data, index, overflowFactor) {\n  var xWertebereich = []\n  xWertebereich[0] = range.min(data, index.accessor)\n  xWertebereich[1] = range.max(data, index.accessor)\n  xWertebereich[1] = range.applyOverflow(xWertebereich[0], xWertebereich[1],\n    overflowFactor, index.data_type)\n  return xWertebereich\n}\n/**\n * Gibt überhöhten Wertebereich für y zurück.\n * @param  {[Array]} data             Gemergter Datensatz, ungefiltert\n * @param  {[Array]} values           Array von Config-Objekten der Wertespalten\n * @param  {[Object]} v_bundle        Accessor-Bundle\n * @param  {[Number]} overflowFactor  Überhöhungsfaktor\n * @return {[Array]}                  Das Minimum und Maximum in einem Array\n */\nmodule.exports.overflowY = function (data, values, v_bundle, overflowFactor) {\n  var yWertebereich = []\n  yWertebereich[0] = range.minMultipleSets(data, values, v_bundle)\n  yWertebereich[1] = range.maxMultipleSets(data, values, v_bundle)\n  yWertebereich[1] = range.applyOverflow(yWertebereich[0], yWertebereich[1],\n    overflowFactor, values[0].data_type)\n  return yWertebereich\n}\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar range = require('./range')\n\n/**\n * Modul: Domain\n * -------------\n * Gibt einen überhöhten Wertbereich zurück für x und y.\n * Überhöhte Wertebereiche werden hier benutzt, damit ein wenig Platz links und\n * oberhalb der Linie entsteht.\n */\n\n/**\n * Gibt überhöhten Wertebereich für x zurück.\n * @param  {[Array]} data             Gemergter Datensatz, ungefiltert\n * @param  {[Object]} index           Config-Objekt für die Index-Spalte\n * @param  {[Number]} overflowFactor  Überhöhungsfaktor\n * @return {[Array]}                  Das Minimum und Maximum in einem Array\n */\nmodule.exports.overflowX = function (data, index, overflowFactor) {\n  var xWertebereich = []\n  xWertebereich[0] = range.min(data, index.accessor)\n  xWertebereich[1] = range.max(data, index.accessor)\n  xWertebereich[1] = range.applyOverflow(xWertebereich[0], xWertebereich[1],\n    overflowFactor, index.data_type)\n  return xWertebereich\n}\n/**\n * Gibt überhöhten Wertebereich für y zurück.\n * @param  {[Array]} data             Gemergter Datensatz, ungefiltert\n * @param  {[Array]} values           Array von Config-Objekten der Wertespalten\n * @param  {[Object]} v_bundle        Accessor-Bundle\n * @param  {[Number]} overflowFactor  Überhöhungsfaktor\n * @return {[Array]}                  Das Minimum und Maximum in einem Array\n */\nmodule.exports.overflowY = function (data, values, v_bundle, overflowFactor) {\n  var yWertebereich = []\n  yWertebereich[0] = range.minMultipleSets(data, values, v_bundle)\n  yWertebereich[1] = range.maxMultipleSets(data, values, v_bundle)\n  yWertebereich[1] = range.applyOverflow(yWertebereich[0], yWertebereich[1],\n    overflowFactor, values[0].data_type)\n  return yWertebereich\n}\n\n},{\"./range\":5}],2:[function(require,module,exports){\n/**\n * Modul: filter\n * -------------\n * Filtert den gemergten Datensatz. Gibt die Zeilen zurück, bei denen die Spalte\n * 'row' gesetzt ist.\n */\n\n/**\n * Gibt den gefilterten Datensatz zurück.\n * @param  {[Array]} data Ungefilterter, gemergter Datensatz.\n * @param  {[String]} row Name der Spalte, nach der gefiltert werden soll\n * @return {[Array]}      Gefilterter, gemergter Datensatz.\n */\n\nmodule.exports.row = function (data, row) {\n  var ret = []\n  for (var i = 0; i < data.length; i++) {\n    if (typeof data[i][row] !== 'undefined') {\n      ret.push(data[i])\n    }\n  }\n  return ret\n}\n\n},{}],3:[function(require,module,exports){\nvar sort = require('./sort')\nvar id = require('./id')\n\n/**\n * Modul: Format\n * -------------\n * Formatiert den Datensatz\n */\n\n/**\n * Konvertiert die Zeichenketten (Strings) im Datensatz in Javascript-\n * Objekte, wie zum Beispiel Zahlen (Float) oder Daten (Date).\n * @param  {[Array]} data   Unformatierter Datensatz\n * @param  {{Array}} config Array von Config-Objekten\n * @return {[Array]}        Gefilterter Datensatz\n */\nmodule.exports.data_types = function (data, config) {\n  // index suchen\n  for (var i = 0; i < data.length; i++) {\n    for (var j = 0; j < config.length; j++) {\n      if (config[j].data_type === 'Number') {\n        data[i][config[j].row] = parseFloat(data[i][config[j].row])\n      } else if (config[j].data_type === 'Date') {\n        data[i][config[j].row] =  d3.time.format(config[j].date_format)\n                                    .parse(data[i][config[j].row])\n      }\n    }\n  }\n  return data\n}\n\n/**\n * Fügt das Attribut 'rowId' für jedes Objekt hinzu. 'rowId' ist eine aus dem\n * Reihennamen und dem Pfad des Datensatzes generierte einzigartie ID.\n * @param  {[Array]} data   Datensatz ohne rowIds\n * @param  {{Array}} config Array von Config-Objekten\n * @return {[Array]}        Datensatz mit rowIds\n */\nmodule.exports.ids = function (data, config) {\n  for (var i = 0; i < data.length; i++) {\n    for (var j = 0; j < config.length; j++) {\n      if (config[j].type === 'index') {\n        continue\n      }\n      data[i][id.get(config[j])] = data[i][config[j].row]\n      delete data[i][config[j].row]\n    }\n  }\n\n  return data\n}\n\n},{\"./id\":4,\"./sort\":6}],4:[function(require,module,exports){\n/**\n * Modul: Id\n * ---------\n * Generiert einzigartige ID für eine Spalte.\n */\n\n/**\n * Gibt generierte ID zurück\n * @param  {[Object]} config Config-Objekt\n * @return {[String]}        ID\n */\nmodule.exports.get = function (config) {\n  return config.row + '#' + config.url\n}\n\n/**\n * Gibt Config-Objekt für eine Spalte zurück\n * @param  {[String]} id    ID der Spalte\n * @param  {[Array]} values Array von Config-Objekten aller Datenspalten\n * @return {[Object]}       Config-Objekt der Spalte\n */\nmodule.exports.invert = function (id, values) {\n  for (var i = 0; i < values.length; i++) {\n    if (id === values[i].rowId) {\n      return values[i]\n    }\n  }\n}\n\n/**\n * Gibt ID für benutzerdefinierte Attribute zurück\n * @param  {[String]} attr Benutzerdefiniertes Attribut\n * @param  {[String]} url  URL des Datensatzes\n * @return {[String]}      ID\n */\nmodule.exports.raw = function (attr, url) {\n  return attr + '#' + url\n}\n\n},{}],5:[function(require,module,exports){\n/**\n * Modul: Range\n * ------------\n * Wertebereich von Datenspalten bestimmen\n */\n\n/**\n * Gibt das Minimum einer einzelnen Datenspalte zurück\n * @param  {[Array]} data           Der Datensatz\n * @param  {{Function}} accessor    Der Accessor für die zu untersuchende Datenreihe\n * @return {[Number]}               Das Minimum\n */\nmodule.exports.min = function (data, accessor) {\n  return d3.min(data, accessor)\n}\n\n/**\n * Gibt das Maximum einer einzelnen Datenspalte zurück\n * @param  {[Array]} data           Der Datensatz\n * @param  {{Function}} index       Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}               Das Maximum\n */\nmodule.exports.max = function (data, accessor) {\n  return d3.max(data, accessor)\n}\n\n/**\n * Gibt das Minimum für mehrere Datenspalten zurück.\n * @param  {[Array]} data           Der Datensatz\n * @param  {[Array]} values         Der Config-Array für die zu untersuchenden\n *                          \t\t\t\tDatenreihen.\n * @param  {{Function}} v_accessor  Die Funktion, die für eine bestimmte value-\n *                                  Reihe den Accessor zurückgibt\n * @return {[Object]}               Das Minimum\n */\nmodule.exports.minMultipleSets = function (data, values, v_bundle) {\n  var min\n  for (var i = 0; i < values.length; i++) {\n    if (!values[i].activated) {\n      continue\n    }\n    var lmin = d3.min(data, v_bundle.raw(values[i]))\n    if (typeof lmin === 'undefined') {\n      continue\n    }\n    if (typeof min === 'undefined' || lmin < min) {\n      min = lmin\n    }\n  }\n  return min\n}\n\n/**\n * Gibt das Maximum für mehrere Datenspalten zurück.\n * @param  {[Array]} data           Der Datensatz\n * @param  {[Array]} values         Der Config-Array für die zu untersuchenden Datenrei-\n *                                  hen.\n * @param  {{Function}} v_accessor  Die Funktion, die für eine bestimmte value-\n *                                  Reihe den Accessor zurückgibt.\n * @return {[Object]}               Das Maximum\n */\nmodule.exports.maxMultipleSets = function (data, values, v_bundle) {\n  var max\n  for (var i = 0; i < values.length; i++) {\n    if (!values[i].activated) {\n      continue\n    }\n    var lmax = d3.max(data, v_bundle.raw(values[i]))\n\n    if (typeof max === 'undefined' || lmax > max) {\n      max = lmax\n    }\n  }\n  return max\n}\n\n//  Wertebereich der Daten bestimmen mit d3: Um einen kleinen Abstand zwischen\n//  den maximalen Punkten und den Rändern des Diagrammes zu bewahren,\n//  wird der Unterschied (Δ) des Minimums und dem untersuchten Wert mit 1.1\n//  mulitpliziert. Anschliessend wird die Summe des Minimums und des\n//  multiplizierten Wertes an d3 zurückgegeben.\n\n/**\n * Gibt die Summe des Minimums und des mit dem Faktor factor multiplizierten\n * Unterschied von min und max zurück.\n * Wird verwendet, damit oben und rechts von Graphen Platz ausgelassen wird.\n * @param  {[Number]} min       Minimum ohne Overflow\n * @param  {[Number]} max       Maximum ohne Overflow\n * @param  {[Number]} factor    Overflow-Faktor\n * @param  {{String}} data_type Der Datentyp von min und max\n * @return {[Number]}           Das Maximum mit Overflow.\n */\nmodule.exports.applyOverflow = function (min, max, factor, data_type) {\n  if (data_type === 'Date') {\n    return new Date(min.getTime() + (max.getTime() - min.getTime()) * factor)\n  } else if (data_type === 'Number') {\n    return min + (max - min) * factor\n  }\n}\n\n},{}],6:[function(require,module,exports){\n/**\n * Modul: Sort\n * -----------\n * Sortiert einen Datensatz nach der Index-Spalte\n */\n\n/**\n * Array sortieren, aufsteigend\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * @return {[Array]} Sortierter Datensatz\n */\nmodule.exports = function (data, index) {\n  data.sort(function (a, b) {\n    if (index.accessor(a) < index.accessor(b)) {\n      return -1\n    }\n    if (index.accessor(a) > index.accessor(b)) {\n      return 1\n    }\n    return 0\n  })\n\n  return data\n}\n\n},{}],7:[function(require,module,exports){\nvar sort = require('./modules/sort')\nvar id = require('./modules/id')\nvar format = require('./modules/format')\nvar filter = require('./modules/filter')\nvar domain = require('./modules/domain')\nvar range = require('./modules/range')\n\n/* global d3, alert */\n\n/*\n *\n *\n * Initialisierung Visualisation\n *\n *\n */\n\n// Für die Visualisation benötigte Variablen\n\nvar config,           // Config-Array für _alle_ Elemente\n  datasetsMeta,       // Das 'datasets'-Attribut von meta.json\n  index,              // Config-Objekt für die Index-Spalte (X-Wert)\n  values,             // Config-Array für Werte-Spalten (Y-Werte)\n  v_accessor,         // Funktion, die den Werteaccessor zurückgibt\n  v_accessor_scaled,  // Funktion, die den skalierten Werteaccessor zurückgibt\n  v_accessor_cord,    // Funktion, die den Koordinatenaccessor zurückgibt\n  v_bundle,           // Objekt, das die drei v-Funktionen enthält\n\n  xScale,             // X-Skala\n  yScale,             // Y-Skala\n\n  w,                  // Breite der Visualisation\n  h,                  // Höhe der Visualisation\n\n  tileW,              // Breite eines Elements in der Matrix\n  tileH               // Höhe eines Elements in der Matrix\n\n/**\n * Laden der Konfigurationsdatei\n * @param  {[String]} \"meta.json\"             Der Dateiname für die\n *                                            Konfigurationsdatei\n * @param  {[Function]} function(err, config) Callback\n */\nd3.json('meta.json', function (err, res) {\n  if (err) {\n    console.log(err)\n    alert(err)\n    return\n  }\n\n  config = []\n  datasetsMeta = res.datasets\n\n  index = {}\n  values = []\n\n  var colors = d3.scale.category20()\n\n  for (var i = 0; i < datasetsMeta.length; i++) {\n    var dataset = datasetsMeta[i]\n    var url = dataset.url\n\n    for (var j = 0; j < dataset.config.length; j++) {\n      var c = dataset.config[j]\n      c.url = url\n\n      // Generiere id\n      c.rowId = id.get(c)\n\n      config.push(c)\n\n      // Einfügen der Config in index oder values\n      if (c.type === 'index') {\n        index = c\n      } else if (c.type === 'value') {\n        // Spaltenspezifische Farbe generieren\n        c.color = colors(values.length + 1)\n\n        // Wenn das Attribut activated nicht gesetzt ist, setze es auf true.\n        if (typeof c.activated === 'undefined') {\n          c.activated = true\n        }\n        values.push(c)\n      }\n    }\n  // Bei unbekannten Typen: nicht in values oder index einfügen.\n  }\n\n  // Datentyp der Skalen festlegen\n  if (index.data_type === 'Number') {\n    xScale = d3.scale.linear()\n  } else if (index.data_type === 'Date') {\n    xScale = d3.time.scale()\n  }\n\n  if (values[0].data_type === 'Number') {\n    yScale = d3.scale.linear()\n  } else if (values[0].data_type === 'Date') {\n    yScale = d3.time.scale()\n  }\n\n  // Höhe und Breite des gesamten SVG-Elements definieren; Verschiebung des\n  // Graphs\n  w = 1100\n  h = 550\n\n  // TODO\n  tileW = 200\n  tileH = 200\n\n  // Wertebereich der Achsenskalierungen definieren. Hier ist die Anzahl der Pixel\n  // gemeint, über die sich die Achsen erstrecken. Die x-Achse und die y-Achse\n  // verschieben wir um 50 nach rechts, damit man die y-Achse beschriften kann.\n  xScale.range([0, tileW])\n  yScale.range([tileH, 0])\n\n  /*\n   *\n   *\n   * Accessors für die Daten\n   *\n   *\n   */\n\n  // Index-Accessor-Funktion: Gibt für eine bestimmte Datenreihe den Wert der\n    // Index-Spalte zurück.\n\n  index.accessor = function (d) {\n    return d[index.row]\n  }\n\n  // ..._scaled: Gibt den skalierten Wert von accessor zurück.\n  index.accessor_scaled = function (d) {\n    return xScale(d[index.row])\n  }\n\n  // Funktion, die die Werte-Accessor-Funktion zurückgibt. Da sich die Werte-\n  // Accessor-Funktionen im Gegensatz zum statischen Index-Accessor unterschei-\n  // den, müssen sie für jede Spalte neu generiert werden. Diese Funktion ist\n  // dafür zuständig.\n\n  v_accessor = function (entry) {\n    return function (d) {\n      return d[entry.rowId]\n    }\n  }\n\n  v_accessor_scaled = function (entry) {\n    return function (d) {\n      return yScale(d[entry.rowId])\n    }\n  }\n\n  // Funktion, die den Koordinatenaccessor für die in entry angegebene Spalte\n  // zurückgibt.\n  v_accessor_cord = function (index, entry) {\n    return function (d) {\n      return [index.accessor_scaled(d), v_accessor_scaled(entry)(d)]\n    }\n  }\n\n  v_bundle = {\n    'raw': v_accessor,\n    'scaled': v_accessor_scaled,\n    'cord': v_accessor_cord\n  }\n\n  // Die Daten laden\n  loadFiles()\n})\n\n/*\n *\n *\n * Laden der Daten\n *\n *\n */\n\n/**\n * Die Funktion, die den Datensatz lädt und vorbereitet.\n *\n * Vorgehen:  1. Laden der Daten\n * \t\t\t\t\t\t2. Formatieren des Datensatzes (data_types und id)\n * \t\t\t\t\t\t3. 'Mergen' mit den anderen Datensätzen, d. h. zusammenfügen\n * \t\t\t\t\t\t4. Sortieren\n * \t\t\t\t\t\t5. Die gemergten Datensätze weitergeben\n */\nfunction loadFiles () {\n  // Anzahl von Dateien, die schon heruntergeladen wurden\n  var loaded = 0\n\n  // Die Variable für die gemergten Datensätze\n  var data = []\n\n  // Jedes einzelne File herunterladen (1)\n  for (var i = 0; i < datasetsMeta.length; i++) {\n    d3.csv(datasetsMeta[i].url, mkcb(i))\n  }\n\n  /**\n   * Funktion, die die Callback-Funktion für einen bestimmten Datensatz-Meta-\n   * daten-Objekt mit Index i zurückgibt. Siehe auch: MKCB-Problem.\n   * @param  {[Number]} i   Index des Datensatz-Metadaten-Objekts aus\n   *                        datasetsMeta.\n   * @return {[Function]}   Das generierte Callback, das nach dem Laden der\n   *                        Datei ausgeführt wird.\n   */\n  function mkcb (i) {\n    return function (err, resp) {\n      if (err) {\n        alert(err)\n        console.log(err)\n        return\n      }\n\n      // Formatieren (2)\n      resp = format.data_types(resp, datasetsMeta[i].config)\n      resp = format.ids(resp, datasetsMeta[i].config)\n\n      // Merge (3)\n      for (var j = 0; j < resp.length; j++) {\n        data.push(resp[j])\n      }\n\n      if (++loaded === datasetsMeta.length) {\n        // Alle Datein sind heruntergeladen worden und gemergt.\n\n        // Sortieren (4)\n        data = sort(data, index)\n\n        // Weitergeben (5)\n        loadVisualization(data)\n      }\n    }\n  }\n}\n\n/*\n *\n *\n * Laden der Visualisation\n *\n *\n */\n\n/**\n * Lädt die Visualisation\n * @param  {[Array]} data Die gemergten Datensätze\n */\nfunction loadVisualization (data) {\n\n\n  // SVG-Element mit id 'visualization' extrahieren aus html\n  var v = d3.select('#visualization')\n    .attr('width', w)\n    .attr('height', h)\n\n  var spaltenAnzahl = values.length + 1\n  tileW = w / spaltenAnzahl\n  tileH = h / spaltenAnzahl\n\n  // Domains\n  xScale.domain(domain.overflowX(data, index, 1.1))\n\n  // testen, ob alle Datensätze die gleiche Länge haben.\n  var buf\n  for (var i = 0; i < values.length; i++) {\n    if (!buf) {\n      buf = filter.row(data, values[i].rowId).length\n    }\n    if (buf !== filter.row(data, values[i].rowId).length) {\n      alert('datasets mismatch')\n    }\n  }\n\n  var graphConfArray = []\n\n  // Funktionen, die entweder den Accessor oder die Skalierung für die entsprechende\n  // Datenspalte zurückgeben: x_ac und y_ac sind für die Accessoren zuständig,\n  // x_sc und y_sc für die Skalierungen.\n\n  function x_ac (ide) {\n    var x_i = ide.split(',')[0]\n    var y_i = ide.split(',')[1]\n    x_i = parseInt(x_i, 10)\n    y_i = parseInt(y_i, 10)\n    return x_i === 0 ? index.accessor : v_bundle.raw(values[x_i - 1])\n  }\n\n  function y_ac (ide) {\n    var x_i = ide.split(',')[0]\n    var y_i = ide.split(',')[1]\n    x_i = parseInt(x_i, 10)\n    y_i = parseInt(y_i, 10)\n    return y_i === 0 ? index.accessor : v_bundle.raw(values[y_i - 1])\n  }\n\n  function x_sc (ide) {\n    var x_i = ide.split(',')[0]\n    x_i = parseInt(x_i, 10)\n\n    var sc\n    if (x_i === 0) {\n      sc = xScale\n    } else {\n      // Datentyp der Spalte festlegen\n      if (values[x_i - 1].data_type === 'Number') {\n        sc = d3.scale.linear()\n      } else if (values[x_i - 1].data_type === 'Date') {\n        sc = d3.time.scale()\n      }\n\n      // Wertebereich der Daten bestimmen\n      var xD = []\n      xD[0] = range.min(data, v_bundle.raw(values[x_i - 1]))\n      xD[1] = range.max(data, v_bundle.raw(values[x_i - 1]))\n      xD[1] = range.applyOverflow(xD[0], xD[1],\n        1.1, values[x_i - 1].data_type)\n      sc.domain(xD)\n    }\n\n    // Wertebereich der Skalierung bestimmen\n    sc.range([0, tileW])\n    return sc\n  }\n  function y_sc (ide) {\n    var y_i = ide.split(',')[1]\n    y_i = parseInt(y_i, 10)\n\n    var sc\n    if (y_i === 0) {\n      sc = xScale\n    } else {\n      // Datentyp bestimmen\n      if (values[y_i - 1].data_type === 'Number') {\n        sc = d3.scale.linear()\n      } else if (values[y_i - 1].data_type === 'Date') {\n        sc = d3.time.scale()\n      }\n\n      // Wertebereich der Daten bestimmen\n      var xD = []\n      xD[0] = range.min(data, v_bundle.raw(values[y_i - 1]))\n      xD[1] = range.max(data, v_bundle.raw(values[y_i - 1]))\n      xD[1] = range.applyOverflow(xD[0], xD[1],\n        1.1, values[y_i - 1].data_type)\n      sc.domain(xD)\n    }\n\n    // Wertebereich der Skalierung bestimmen\n    sc.range([tileH, 0])\n    return sc\n  }\n\n  for (var i = 0; i < spaltenAnzahl; i++) {\n    for (var j = 0; j < spaltenAnzahl; j++) {\n      if (i !== j) {\n        var xConfig\n        var data_tmp = []\n        var copy = []\n\n        if (i === 0) {\n          xConfig = index\n        } else {\n          xConfig = values[i - 1]\n          copy = filter.row(data, values[i - 1].rowId)\n        }\n\n        var yConfig\n\n        if (j === 0) {\n          yConfig = index\n          data_tmp = copy\n        } else {\n          yConfig = values[j - 1]\n          // Datensatz zusammenführen, falls im ersten Fall bei X ebenfalls\n          // eine Wertespalte benutzt wurde\n\n          var data_to_merge = []\n          data_to_merge = filter.row(data, values[j - 1].rowId)\n\n          // Daten \"unlinken\", Referenz zum Original-Objekt zerstören\n          var here = JSON.parse(JSON.stringify(copy))\n\n          // Zusammenführen\n          if (here.length !== 0) {\n            for (var k = 0; k < data_to_merge.length; k++) {\n              here[k][values[j - 1].rowId] = y_ac(i + ',' + j)(data_to_merge[k])\n            }\n            data_tmp = here\n            copy = undefined\n          } else {\n            data_tmp = data_to_merge\n          }\n        }\n\n        // Die berechneten Attribute in einem Objekt speichern und graphConfArray\n        // übergeben.\n        var obj = {\n          xConfig: xConfig,\n          yConfig: yConfig,\n          data: data_tmp,\n          id: i + ',' + j\n        }\n        graphConfArray.push(obj)\n      }\n    }\n  }\n\n  // Matrix zeichnen\n  var c = 0\n  for (var i = 0; i < spaltenAnzahl; i++) {\n    for (var j = 0; j < spaltenAnzahl; j++) {\n      if (i !== j) {\n        drawGraph(i, j, graphConfArray[c++])\n      } else {\n        var name\n        if (i === 0) {\n          name = (index.name ? index.name : index.row) + (index.unit ? (' in ' + index.unit) : '')\n        } else {\n          name = (values[i - 1].name ? values[i - 1].name : values[i - 1].row) + (values[i - 1].unit ? (' in ' + values[i - 1].unit) : '')\n        }\n        drawLabel(i, j, name)\n      }\n    }\n  }\n\n  /**\n   * Zeichnet die Beschriftung\n   */\n  function drawLabel (zeile, spalte, name) {\n    v.append('rect')\n      .attr('x', spalte * tileW)\n      .attr('y', zeile * tileH)\n      .attr('width', tileW)\n      .attr('height', tileH)\n      .classed('label', true)\n    v.append('text')\n      .classed('label-text', true)\n      .attr('text-anchor', 'middle')\n      .attr('alignment-baseline', 'middle')\n      .attr('x', spalte * tileW + tileW * 0.5)\n      .attr('y', zeile * tileH + tileH * 0.5)\n      .html(name)\n  }\n\n  /**\n   * Zeichnet den Graphen\n   */\n  function drawGraph (zeile, spalte, config) {\n    var x = spalte * tileW\n    var y = zeile * tileH\n    items(x, y, config, (zeile + '-' + spalte))\n  }\n\n  /**\n   * Zeichnet die einzelnen Graphen in der Matrix an der Position x, y\n   */\n  function items (x, y, config, graphId) {\n    // Container für die Visualisation hinzufügen und zur Maske \"linken\"\n    // Transformation nach den definierten Angaben mit transform, translate\n\n    var graph = v.append('g')\n      .attr('id', graphId)\n      .attr('transform', 'translate(' + x +\n        ',' + y + ')')\n\n    graph.append('rect')\n      .attr('class', 'tile')\n      .attr('width', tileW)\n      .attr('height', tileH)\n\n    var circles = graph.selectAll('circle')\n\n      // Aus dem gesamten gemergten Datensatz die Elemente extrahieren, die die\n      // entsprechende Reihe besitzen. Siehe Merge-Problem.\n      // Daten an Selektion binden: Alle Aktionen, die an diesem einem Element\n      // ausgeführt werden, werden auch bei allen anderen Datenreihen ausgeführt.\n      .data(config.data).enter()\n\n    // Aktionen an datengebundener Selektion ausführen\n    circles.append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', function (d) {\n        // Skalierung und Accessor durch Superaccessoren abrufen\n        var scale = x_sc(config.id)\n        var ac = x_ac(config.id)\n        return scale(ac(d))\n      })\n      .attr('cy', function (d) {\n        // Skalierung und Accessor durch Superaccessoren abrufen\n        var scale = y_sc(config.id)\n        var ac = y_ac(config.id)\n        return scale(ac(d))\n      })\n  }\n}\n\n},{\"./modules/domain\":1,\"./modules/filter\":2,\"./modules/format\":3,\"./modules/id\":4,\"./modules/range\":5,\"./modules/sort\":6}]},{},[7])\n\n","/**\n * Modul: filter\n * -------------\n * Filtert den gemergten Datensatz. Gibt die Zeilen zurück, bei denen die Spalte\n * 'row' gesetzt ist.\n */\n\n/**\n * Gibt den gefilterten Datensatz zurück.\n * @param  {[Array]} data Ungefilterter, gemergter Datensatz.\n * @param  {[String]} row Name der Spalte, nach der gefiltert werden soll\n * @return {[Array]}      Gefilterter, gemergter Datensatz.\n */\n\nmodule.exports.row = function (data, row) {\n  var ret = []\n  for (var i = 0; i < data.length; i++) {\n    if (typeof data[i][row] !== 'undefined') {\n      ret.push(data[i])\n    }\n  }\n  return ret\n}\n","var sort = require('./sort')\nvar id = require('./id')\n\n/**\n * Modul: Format\n * -------------\n * Formatiert den Datensatz\n */\n\n/**\n * Konvertiert die Zeichenketten (Strings) im Datensatz in Javascript-\n * Objekte, wie zum Beispiel Zahlen (Float) oder Daten (Date).\n * @param  {[Array]} data   Unformatierter Datensatz\n * @param  {{Array}} config Array von Config-Objekten\n * @return {[Array]}        Gefilterter Datensatz\n */\nmodule.exports.data_types = function (data, config) {\n  // index suchen\n  for (var i = 0; i < data.length; i++) {\n    for (var j = 0; j < config.length; j++) {\n      if (config[j].data_type === 'Number') {\n        data[i][config[j].row] = parseFloat(data[i][config[j].row])\n      } else if (config[j].data_type === 'Date') {\n        data[i][config[j].row] =  d3.time.format(config[j].date_format)\n                                    .parse(data[i][config[j].row])\n      }\n    }\n  }\n  return data\n}\n\n/**\n * Fügt das Attribut 'rowId' für jedes Objekt hinzu. 'rowId' ist eine aus dem\n * Reihennamen und dem Pfad des Datensatzes generierte einzigartie ID.\n * @param  {[Array]} data   Datensatz ohne rowIds\n * @param  {{Array}} config Array von Config-Objekten\n * @return {[Array]}        Datensatz mit rowIds\n */\nmodule.exports.ids = function (data, config) {\n  for (var i = 0; i < data.length; i++) {\n    for (var j = 0; j < config.length; j++) {\n      if (config[j].type === 'index') {\n        continue\n      }\n      data[i][id.get(config[j])] = data[i][config[j].row]\n      delete data[i][config[j].row]\n    }\n  }\n\n  return data\n}\n","/**\n * Modul: Id\n * ---------\n * Generiert einzigartige ID für eine Spalte.\n */\n\n/**\n * Gibt generierte ID zurück\n * @param  {[Object]} config Config-Objekt\n * @return {[String]}        ID\n */\nmodule.exports.get = function (config) {\n  return config.row + '#' + config.url\n}\n\n/**\n * Gibt Config-Objekt für eine Spalte zurück\n * @param  {[String]} id    ID der Spalte\n * @param  {[Array]} values Array von Config-Objekten aller Datenspalten\n * @return {[Object]}       Config-Objekt der Spalte\n */\nmodule.exports.invert = function (id, values) {\n  for (var i = 0; i < values.length; i++) {\n    if (id === values[i].rowId) {\n      return values[i]\n    }\n  }\n}\n\n/**\n * Gibt ID für benutzerdefinierte Attribute zurück\n * @param  {[String]} attr Benutzerdefiniertes Attribut\n * @param  {[String]} url  URL des Datensatzes\n * @return {[String]}      ID\n */\nmodule.exports.raw = function (attr, url) {\n  return attr + '#' + url\n}\n","/**\n * Modul: Range\n * ------------\n * Wertebereich von Datenspalten bestimmen\n */\n\n/**\n * Gibt das Minimum einer einzelnen Datenspalte zurück\n * @param  {[Array]} data           Der Datensatz\n * @param  {{Function}} accessor    Der Accessor für die zu untersuchende Datenreihe\n * @return {[Number]}               Das Minimum\n */\nmodule.exports.min = function (data, accessor) {\n  return d3.min(data, accessor)\n}\n\n/**\n * Gibt das Maximum einer einzelnen Datenspalte zurück\n * @param  {[Array]} data           Der Datensatz\n * @param  {{Function}} index       Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}               Das Maximum\n */\nmodule.exports.max = function (data, accessor) {\n  return d3.max(data, accessor)\n}\n\n/**\n * Gibt das Minimum für mehrere Datenspalten zurück.\n * @param  {[Array]} data           Der Datensatz\n * @param  {[Array]} values         Der Config-Array für die zu untersuchenden\n *                          \t\t\t\tDatenreihen.\n * @param  {{Function}} v_accessor  Die Funktion, die für eine bestimmte value-\n *                                  Reihe den Accessor zurückgibt\n * @return {[Object]}               Das Minimum\n */\nmodule.exports.minMultipleSets = function (data, values, v_bundle) {\n  var min\n  for (var i = 0; i < values.length; i++) {\n    if (!values[i].activated) {\n      continue\n    }\n    var lmin = d3.min(data, v_bundle.raw(values[i]))\n    if (typeof lmin === 'undefined') {\n      continue\n    }\n    if (typeof min === 'undefined' || lmin < min) {\n      min = lmin\n    }\n  }\n  return min\n}\n\n/**\n * Gibt das Maximum für mehrere Datenspalten zurück.\n * @param  {[Array]} data           Der Datensatz\n * @param  {[Array]} values         Der Config-Array für die zu untersuchenden Datenrei-\n *                                  hen.\n * @param  {{Function}} v_accessor  Die Funktion, die für eine bestimmte value-\n *                                  Reihe den Accessor zurückgibt.\n * @return {[Object]}               Das Maximum\n */\nmodule.exports.maxMultipleSets = function (data, values, v_bundle) {\n  var max\n  for (var i = 0; i < values.length; i++) {\n    if (!values[i].activated) {\n      continue\n    }\n    var lmax = d3.max(data, v_bundle.raw(values[i]))\n\n    if (typeof max === 'undefined' || lmax > max) {\n      max = lmax\n    }\n  }\n  return max\n}\n\n//  Wertebereich der Daten bestimmen mit d3: Um einen kleinen Abstand zwischen\n//  den maximalen Punkten und den Rändern des Diagrammes zu bewahren,\n//  wird der Unterschied (Δ) des Minimums und dem untersuchten Wert mit 1.1\n//  mulitpliziert. Anschliessend wird die Summe des Minimums und des\n//  multiplizierten Wertes an d3 zurückgegeben.\n\n/**\n * Gibt die Summe des Minimums und des mit dem Faktor factor multiplizierten\n * Unterschied von min und max zurück.\n * Wird verwendet, damit oben und rechts von Graphen Platz ausgelassen wird.\n * @param  {[Number]} min       Minimum ohne Overflow\n * @param  {[Number]} max       Maximum ohne Overflow\n * @param  {[Number]} factor    Overflow-Faktor\n * @param  {{String}} data_type Der Datentyp von min und max\n * @return {[Number]}           Das Maximum mit Overflow.\n */\nmodule.exports.applyOverflow = function (min, max, factor, data_type) {\n  if (data_type === 'Date') {\n    return new Date(min.getTime() + (max.getTime() - min.getTime()) * factor)\n  } else if (data_type === 'Number') {\n    return min + (max - min) * factor\n  }\n}\n","/**\n * Modul: Sort\n * -----------\n * Sortiert einen Datensatz nach der Index-Spalte\n */\n\n/**\n * Array sortieren, aufsteigend\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * @return {[Array]} Sortierter Datensatz\n */\nmodule.exports = function (data, index) {\n  data.sort(function (a, b) {\n    if (index.accessor(a) < index.accessor(b)) {\n      return -1\n    }\n    if (index.accessor(a) > index.accessor(b)) {\n      return 1\n    }\n    return 0\n  })\n\n  return data\n}\n","var sort = require('./modules/sort')\nvar id = require('./modules/id')\nvar format = require('./modules/format')\nvar filter = require('./modules/filter')\nvar domain = require('./modules/domain')\nvar range = require('./modules/range')\n\n/* global d3, alert */\n\n/*\n *\n *\n * Initialisierung Visualisation\n *\n *\n */\n\n// Für die Visualisation benötigte Variablen\n\nvar config,           // Config-Array für _alle_ Elemente\n  datasetsMeta,       // Das 'datasets'-Attribut von meta.json\n  index,              // Config-Objekt für die Index-Spalte (X-Wert)\n  values,             // Config-Array für Werte-Spalten (Y-Werte)\n  v_accessor,         // Funktion, die den Werteaccessor zurückgibt\n  v_accessor_scaled,  // Funktion, die den skalierten Werteaccessor zurückgibt\n  v_accessor_cord,    // Funktion, die den Koordinatenaccessor zurückgibt\n  v_bundle,           // Objekt, das die drei v-Funktionen enthält\n\n  xScale,             // X-Skala\n  yScale,             // Y-Skala\n\n  w,                  // Breite der Visualisation\n  h,                  // Höhe der Visualisation\n\n  tileW,              // Breite eines Elements in der Matrix\n  tileH               // Höhe eines Elements in der Matrix\n\n/**\n * Laden der Konfigurationsdatei\n * @param  {[String]} \"meta.json\"             Der Dateiname für die\n *                                            Konfigurationsdatei\n * @param  {[Function]} function(err, config) Callback\n */\nd3.json('meta.json', function (err, res) {\n  if (err) {\n    console.log(err)\n    alert(err)\n    return\n  }\n\n  config = []\n  datasetsMeta = res.datasets\n\n  index = {}\n  values = []\n\n  var colors = d3.scale.category20()\n\n  for (var i = 0; i < datasetsMeta.length; i++) {\n    var dataset = datasetsMeta[i]\n    var url = dataset.url\n\n    for (var j = 0; j < dataset.config.length; j++) {\n      var c = dataset.config[j]\n      c.url = url\n\n      // Generiere id\n      c.rowId = id.get(c)\n\n      config.push(c)\n\n      // Einfügen der Config in index oder values\n      if (c.type === 'index') {\n        index = c\n      } else if (c.type === 'value') {\n        // Spaltenspezifische Farbe generieren\n        c.color = colors(values.length + 1)\n\n        // Wenn das Attribut activated nicht gesetzt ist, setze es auf true.\n        if (typeof c.activated === 'undefined') {\n          c.activated = true\n        }\n        values.push(c)\n      }\n    }\n  // Bei unbekannten Typen: nicht in values oder index einfügen.\n  }\n\n  // Datentyp der Skalen festlegen\n  if (index.data_type === 'Number') {\n    xScale = d3.scale.linear()\n  } else if (index.data_type === 'Date') {\n    xScale = d3.time.scale()\n  }\n\n  if (values[0].data_type === 'Number') {\n    yScale = d3.scale.linear()\n  } else if (values[0].data_type === 'Date') {\n    yScale = d3.time.scale()\n  }\n\n  // Höhe und Breite des gesamten SVG-Elements definieren; Verschiebung des\n  // Graphs\n  w = 1100\n  h = 550\n\n  // TODO\n  tileW = 200\n  tileH = 200\n\n  // Wertebereich der Achsenskalierungen definieren. Hier ist die Anzahl der Pixel\n  // gemeint, über die sich die Achsen erstrecken. Die x-Achse und die y-Achse\n  // verschieben wir um 50 nach rechts, damit man die y-Achse beschriften kann.\n  xScale.range([0, tileW])\n  yScale.range([tileH, 0])\n\n  /*\n   *\n   *\n   * Accessors für die Daten\n   *\n   *\n   */\n\n  // Index-Accessor-Funktion: Gibt für eine bestimmte Datenreihe den Wert der\n    // Index-Spalte zurück.\n\n  index.accessor = function (d) {\n    return d[index.row]\n  }\n\n  // ..._scaled: Gibt den skalierten Wert von accessor zurück.\n  index.accessor_scaled = function (d) {\n    return xScale(d[index.row])\n  }\n\n  // Funktion, die die Werte-Accessor-Funktion zurückgibt. Da sich die Werte-\n  // Accessor-Funktionen im Gegensatz zum statischen Index-Accessor unterschei-\n  // den, müssen sie für jede Spalte neu generiert werden. Diese Funktion ist\n  // dafür zuständig.\n\n  v_accessor = function (entry) {\n    return function (d) {\n      return d[entry.rowId]\n    }\n  }\n\n  v_accessor_scaled = function (entry) {\n    return function (d) {\n      return yScale(d[entry.rowId])\n    }\n  }\n\n  // Funktion, die den Koordinatenaccessor für die in entry angegebene Spalte\n  // zurückgibt.\n  v_accessor_cord = function (index, entry) {\n    return function (d) {\n      return [index.accessor_scaled(d), v_accessor_scaled(entry)(d)]\n    }\n  }\n\n  v_bundle = {\n    'raw': v_accessor,\n    'scaled': v_accessor_scaled,\n    'cord': v_accessor_cord\n  }\n\n  // Die Daten laden\n  loadFiles()\n})\n\n/*\n *\n *\n * Laden der Daten\n *\n *\n */\n\n/**\n * Die Funktion, die den Datensatz lädt und vorbereitet.\n *\n * Vorgehen:  1. Laden der Daten\n * \t\t\t\t\t\t2. Formatieren des Datensatzes (data_types und id)\n * \t\t\t\t\t\t3. 'Mergen' mit den anderen Datensätzen, d. h. zusammenfügen\n * \t\t\t\t\t\t4. Sortieren\n * \t\t\t\t\t\t5. Die gemergten Datensätze weitergeben\n */\nfunction loadFiles () {\n  // Anzahl von Dateien, die schon heruntergeladen wurden\n  var loaded = 0\n\n  // Die Variable für die gemergten Datensätze\n  var data = []\n\n  // Jedes einzelne File herunterladen (1)\n  for (var i = 0; i < datasetsMeta.length; i++) {\n    d3.csv(datasetsMeta[i].url, mkcb(i))\n  }\n\n  /**\n   * Funktion, die die Callback-Funktion für einen bestimmten Datensatz-Meta-\n   * daten-Objekt mit Index i zurückgibt. Siehe auch: MKCB-Problem.\n   * @param  {[Number]} i   Index des Datensatz-Metadaten-Objekts aus\n   *                        datasetsMeta.\n   * @return {[Function]}   Das generierte Callback, das nach dem Laden der\n   *                        Datei ausgeführt wird.\n   */\n  function mkcb (i) {\n    return function (err, resp) {\n      if (err) {\n        alert(err)\n        console.log(err)\n        return\n      }\n\n      // Formatieren (2)\n      resp = format.data_types(resp, datasetsMeta[i].config)\n      resp = format.ids(resp, datasetsMeta[i].config)\n\n      // Merge (3)\n      for (var j = 0; j < resp.length; j++) {\n        data.push(resp[j])\n      }\n\n      if (++loaded === datasetsMeta.length) {\n        // Alle Datein sind heruntergeladen worden und gemergt.\n\n        // Sortieren (4)\n        data = sort(data, index)\n\n        // Weitergeben (5)\n        loadVisualization(data)\n      }\n    }\n  }\n}\n\n/*\n *\n *\n * Laden der Visualisation\n *\n *\n */\n\n/**\n * Lädt die Visualisation\n * @param  {[Array]} data Die gemergten Datensätze\n */\nfunction loadVisualization (data) {\n\n\n  // SVG-Element mit id 'visualization' extrahieren aus html\n  var v = d3.select('#visualization')\n    .attr('width', w)\n    .attr('height', h)\n\n  var spaltenAnzahl = values.length + 1\n  tileW = w / spaltenAnzahl\n  tileH = h / spaltenAnzahl\n\n  // Domains\n  xScale.domain(domain.overflowX(data, index, 1.1))\n\n  // testen, ob alle Datensätze die gleiche Länge haben.\n  var buf\n  for (var i = 0; i < values.length; i++) {\n    if (!buf) {\n      buf = filter.row(data, values[i].rowId).length\n    }\n    if (buf !== filter.row(data, values[i].rowId).length) {\n      alert('datasets mismatch')\n    }\n  }\n\n  var graphConfArray = []\n\n  // Funktionen, die entweder den Accessor oder die Skalierung für die entsprechende\n  // Datenspalte zurückgeben: x_ac und y_ac sind für die Accessoren zuständig,\n  // x_sc und y_sc für die Skalierungen.\n\n  function x_ac (ide) {\n    var x_i = ide.split(',')[0]\n    var y_i = ide.split(',')[1]\n    x_i = parseInt(x_i, 10)\n    y_i = parseInt(y_i, 10)\n    return x_i === 0 ? index.accessor : v_bundle.raw(values[x_i - 1])\n  }\n\n  function y_ac (ide) {\n    var x_i = ide.split(',')[0]\n    var y_i = ide.split(',')[1]\n    x_i = parseInt(x_i, 10)\n    y_i = parseInt(y_i, 10)\n    return y_i === 0 ? index.accessor : v_bundle.raw(values[y_i - 1])\n  }\n\n  function x_sc (ide) {\n    var x_i = ide.split(',')[0]\n    x_i = parseInt(x_i, 10)\n\n    var sc\n    if (x_i === 0) {\n      sc = xScale\n    } else {\n      // Datentyp der Spalte festlegen\n      if (values[x_i - 1].data_type === 'Number') {\n        sc = d3.scale.linear()\n      } else if (values[x_i - 1].data_type === 'Date') {\n        sc = d3.time.scale()\n      }\n\n      // Wertebereich der Daten bestimmen\n      var xD = []\n      xD[0] = range.min(data, v_bundle.raw(values[x_i - 1]))\n      xD[1] = range.max(data, v_bundle.raw(values[x_i - 1]))\n      xD[1] = range.applyOverflow(xD[0], xD[1],\n        1.1, values[x_i - 1].data_type)\n      sc.domain(xD)\n    }\n\n    // Wertebereich der Skalierung bestimmen\n    sc.range([0, tileW])\n    return sc\n  }\n  function y_sc (ide) {\n    var y_i = ide.split(',')[1]\n    y_i = parseInt(y_i, 10)\n\n    var sc\n    if (y_i === 0) {\n      sc = xScale\n    } else {\n      // Datentyp bestimmen\n      if (values[y_i - 1].data_type === 'Number') {\n        sc = d3.scale.linear()\n      } else if (values[y_i - 1].data_type === 'Date') {\n        sc = d3.time.scale()\n      }\n\n      // Wertebereich der Daten bestimmen\n      var xD = []\n      xD[0] = range.min(data, v_bundle.raw(values[y_i - 1]))\n      xD[1] = range.max(data, v_bundle.raw(values[y_i - 1]))\n      xD[1] = range.applyOverflow(xD[0], xD[1],\n        1.1, values[y_i - 1].data_type)\n      sc.domain(xD)\n    }\n\n    // Wertebereich der Skalierung bestimmen\n    sc.range([tileH, 0])\n    return sc\n  }\n\n  for (var i = 0; i < spaltenAnzahl; i++) {\n    for (var j = 0; j < spaltenAnzahl; j++) {\n      if (i !== j) {\n        var xConfig\n        var data_tmp = []\n        var copy = []\n\n        if (i === 0) {\n          xConfig = index\n        } else {\n          xConfig = values[i - 1]\n          copy = filter.row(data, values[i - 1].rowId)\n        }\n\n        var yConfig\n\n        if (j === 0) {\n          yConfig = index\n          data_tmp = copy\n        } else {\n          yConfig = values[j - 1]\n          // Datensatz zusammenführen, falls im ersten Fall bei X ebenfalls\n          // eine Wertespalte benutzt wurde\n\n          var data_to_merge = []\n          data_to_merge = filter.row(data, values[j - 1].rowId)\n\n          // Daten \"unlinken\", Referenz zum Original-Objekt zerstören\n          var here = JSON.parse(JSON.stringify(copy))\n\n          // Zusammenführen\n          if (here.length !== 0) {\n            for (var k = 0; k < data_to_merge.length; k++) {\n              here[k][values[j - 1].rowId] = y_ac(i + ',' + j)(data_to_merge[k])\n            }\n            data_tmp = here\n            copy = undefined\n          } else {\n            data_tmp = data_to_merge\n          }\n        }\n\n        // Die berechneten Attribute in einem Objekt speichern und graphConfArray\n        // übergeben.\n        var obj = {\n          xConfig: xConfig,\n          yConfig: yConfig,\n          data: data_tmp,\n          id: i + ',' + j\n        }\n        graphConfArray.push(obj)\n      }\n    }\n  }\n\n  // Matrix zeichnen\n  var c = 0\n  for (var i = 0; i < spaltenAnzahl; i++) {\n    for (var j = 0; j < spaltenAnzahl; j++) {\n      if (i !== j) {\n        drawGraph(i, j, graphConfArray[c++])\n      } else {\n        var name\n        if (i === 0) {\n          name = (index.name ? index.name : index.row) + (index.unit ? (' in ' + index.unit) : '')\n        } else {\n          name = (values[i - 1].name ? values[i - 1].name : values[i - 1].row) + (values[i - 1].unit ? (' in ' + values[i - 1].unit) : '')\n        }\n        drawLabel(i, j, name)\n      }\n    }\n  }\n\n  /**\n   * Zeichnet die Beschriftung\n   */\n  function drawLabel (zeile, spalte, name) {\n    v.append('rect')\n      .attr('x', spalte * tileW)\n      .attr('y', zeile * tileH)\n      .attr('width', tileW)\n      .attr('height', tileH)\n      .classed('label', true)\n    v.append('text')\n      .classed('label-text', true)\n      .attr('text-anchor', 'middle')\n      .attr('alignment-baseline', 'middle')\n      .attr('x', spalte * tileW + tileW * 0.5)\n      .attr('y', zeile * tileH + tileH * 0.5)\n      .html(name)\n  }\n\n  /**\n   * Zeichnet den Graphen\n   */\n  function drawGraph (zeile, spalte, config) {\n    var x = spalte * tileW\n    var y = zeile * tileH\n    items(x, y, config, (zeile + '-' + spalte))\n  }\n\n  /**\n   * Zeichnet die einzelnen Graphen in der Matrix an der Position x, y\n   */\n  function items (x, y, config, graphId) {\n    // Container für die Visualisation hinzufügen und zur Maske \"linken\"\n    // Transformation nach den definierten Angaben mit transform, translate\n\n    var graph = v.append('g')\n      .attr('id', graphId)\n      .attr('transform', 'translate(' + x +\n        ',' + y + ')')\n\n    graph.append('rect')\n      .attr('class', 'tile')\n      .attr('width', tileW)\n      .attr('height', tileH)\n\n    var circles = graph.selectAll('circle')\n\n      // Aus dem gesamten gemergten Datensatz die Elemente extrahieren, die die\n      // entsprechende Reihe besitzen. Siehe Merge-Problem.\n      // Daten an Selektion binden: Alle Aktionen, die an diesem einem Element\n      // ausgeführt werden, werden auch bei allen anderen Datenreihen ausgeführt.\n      .data(config.data).enter()\n\n    // Aktionen an datengebundener Selektion ausführen\n    circles.append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', function (d) {\n        // Skalierung und Accessor durch Superaccessoren abrufen\n        var scale = x_sc(config.id)\n        var ac = x_ac(config.id)\n        return scale(ac(d))\n      })\n      .attr('cy', function (d) {\n        // Skalierung und Accessor durch Superaccessoren abrufen\n        var scale = y_sc(config.id)\n        var ac = y_ac(config.id)\n        return scale(ac(d))\n      })\n  }\n}\n"],"sourceRoot":"/source/"}