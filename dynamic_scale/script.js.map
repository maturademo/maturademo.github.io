{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","tests/dynamic_scale/modules/domain.js","script.js","tests/dynamic_scale/modules/filter.js","tests/dynamic_scale/modules/format.js","tests/dynamic_scale/modules/id.js","tests/dynamic_scale/modules/line.js","tests/dynamic_scale/modules/points.js","tests/dynamic_scale/modules/range.js","tests/dynamic_scale/modules/sort.js","tests/dynamic_scale/modules/tooltip.js","tests/dynamic_scale/script.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","range","overflowX","data","index","overflowFactor","xWertebereich","min","accessor","max","applyOverflow","data_type","overflowY","values","v_accessor","yWertebereich","minMultipleSets","maxMultipleSets","./range",2,"row","ret","push",3,"id","data_types","config","j","parseFloat","d3","time","format","date_format","parse","ids","console","log","type","get","./id","./sort",4,"url","invert","rowId","raw","attr",5,"points","mode","addLine","accessor_cord","path","select","append","color","linear","svg","line","x","accessor_scaled_x","y","accessor_scaled_y","interpolate","temp","coordinates","update","value","v_accessor_scaled","v_accessor_cord","accessor_scaled","setActivated","activated","points_s","selectAll","classed","updateVisibility","./points",6,"visible",7,"lmin","lmax","factor","Date","getTime",8,"sort","b",9,"opt","nextIndex","item","this_d","next","afterThis","beforeNext","Δ1","Math","abs","Δ2","tooltip","parent","textAccessor","tip","empty","label","text","cord","updateTooltip","xScale","yScale","mouse","graphTransform","xstart","x_date","tooltipIndex","d","round",10,"loadFiles","mkcb","err","resp","alert","datasetsMeta","loaded","loadVisualization","csv","draw","xAxisContainer","xAxis","yAxisContainer","yAxis","v","filter","updateDomain","zoom","scale","translate","domain","graph","behavior","scaleExtent","on","w","h","xend","ytop","ybottom","circles","enter","this","$","showPoints","is","name","hasClass","toggleClass","json","res","datasets","colors","category20","dataset","c","axis","orient","ticks","entry","./modules/domain","./modules/filter","./modules/format","./modules/id","./modules/line","./modules/points","./modules/sort","./modules/tooltip"],"mappings":"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","file":"script.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var range = require('./range');\n\nmodule.exports.overflowX = function(data, index, overflowFactor){\n  var xWertebereich = [];\n  xWertebereich[0] = range.min(data, index.accessor);\n  xWertebereich[1] = range.max(data, index.accessor);\n  xWertebereich[1] = range.applyOverflow(xWertebereich[0], xWertebereich[1],\n    overflowFactor, index.data_type);\n  return xWertebereich;\n}\n\nmodule.exports.overflowY = function(data, values, v_accessor, overflowFactor) {\n  var yWertebereich = [];\n  yWertebereich[0] = range.minMultipleSets(data, values, v_accessor);\n  yWertebereich[1] = range.maxMultipleSets(data, values, v_accessor);\n  yWertebereich[1] = range.applyOverflow(yWertebereich[0], yWertebereich[1],\n    overflowFactor, values[0].data_type);\n  return yWertebereich;\n}\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar range = require('./range');\n\nmodule.exports.overflowX = function(data, index, overflowFactor){\n  var xWertebereich = [];\n  xWertebereich[0] = range.min(data, index.accessor);\n  xWertebereich[1] = range.max(data, index.accessor);\n  xWertebereich[1] = range.applyOverflow(xWertebereich[0], xWertebereich[1],\n    overflowFactor, index.data_type);\n  return xWertebereich;\n}\n\nmodule.exports.overflowY = function(data, values, v_accessor, overflowFactor) {\n  var yWertebereich = [];\n  yWertebereich[0] = range.minMultipleSets(data, values, v_accessor);\n  yWertebereich[1] = range.maxMultipleSets(data, values, v_accessor);\n  yWertebereich[1] = range.applyOverflow(yWertebereich[0], yWertebereich[1],\n    overflowFactor, values[0].data_type);\n  return yWertebereich;\n}\n\n},{\"./range\":7}],2:[function(require,module,exports){\nmodule.exports.row = function(data, row) {\n  var ret = [];\n  for(var i = 0; i<data.length; i++){\n    if(typeof data[i][row] !== \"undefined\"){\n      ret.push(data[i]);\n    }\n  }\n  return ret;\n}\n\n},{}],3:[function(require,module,exports){\nvar sort = require('./sort');\nvar id = require('./id');\n\nmodule.exports.data_types = function(data, config) {\n  // index suchen\n  for(var i = 0; i<data.length; i++) {\n    for(var j = 0; j<config.length; j++) {\n      if(config[j].data_type == \"Number\") {\n        data[i][config[j].row] = parseFloat(data[i][config[j].row]);\n      } else if(config[j].data_type == \"Date\") {\n        data[i][config[j].row] =  d3.time.format(config[j].date_format)\n                                    .parse(data[i][config[j].row]);\n      }\n    }\n  }\n  return data;\n}\n\nmodule.exports.ids = function(data, config) {\n  console.log(data);\n  console.log(config);\n\n  for(var i = 0; i<data.length; i++) {\n    for(var j = 0; j<config.length; j++){\n      if(config[j].type == \"index\"){\n        continue;\n      }\n      data[i][id.get(config[j])] = data[i][config[j].row];\n      delete data[i][config[j].row];\n    }\n  }\n\n  return data;\n}\n\n},{\"./id\":4,\"./sort\":8}],4:[function(require,module,exports){\nmodule.exports.get = function(config) {\n  return config.row + \"#\" + config.url;\n}\n\n// ret value config obj\nmodule.exports.invert = function(id, values) {\n  for(var i = 0; i<values.length; i++) {\n    if(id == values[i].rowId) {\n      return values[i];\n    }\n  }\n}\n\nmodule.exports.raw = function(attr, url) {\n  return attr+\"#\"+url;\n}\n\n},{}],5:[function(require,module,exports){\nvar points = require(\"./points\");\n\n/**\n * Html-Element select zur Auswahl des Modus: Die Variable 'mode' bei\n * Änderung aktualisieren.\n *\n * Checkbox 'Punkte anzeigen': Die Datenpunkte anzeigen / verstecken.\n */\n\nmodule.exports.mode = \"undefined\";\n\n/**\n * Fügt eine Linie hinzu.\n * @param  {[Object]} index  Die Config des Indexes.\n * @param  {[Object]} config Die Config der betreffenden Spalte.\n */\nmodule.exports.addLine = function(index, config, data, accessor_cord) {\n  var path = d3.select(\"#graph\")\n   .append(\"path\")\n   .attr(\"class\", \"line\")\n   .attr(\"style\", \"stroke:\"+config.color)\n   .attr(\"data-row\", config.rowId);\n\n   if(module.exports.mode == \"linear\" || module.exports.mode == \"undefined\"){\n      path.attr(\"d\", module.exports.linear(data, accessor_cord));\n   } else {\n     var line = d3.svg.line()\n       .x(accessor_scaled_x)\n       .y(accessor_scaled_y)\n       .interpolate(module.exports.mode);\n   }\n}\n\n/**\n * Gibt die Lineare Interpolation als SVG-Path-String zurück\n * @param  {[Array]} data        Das Datenarray\n * @param  {{Function}} accessor Die Funktion, welche die Koordinaten zurück-\n *                               gibt des entsprechenden Punktes\n * @return {[String]}            String, das in das Attribut 'd' im path-\n *                               Element eingesetzt werden muss.\n */\nmodule.exports.linear = function(data, accessor) {\n  var path = \"\";\n\n  //figure out\n  var temp = \"Weighted Price\";\n\n  for(var i = 0; i < data.length; i++) {\n    var coordinates = accessor(data[i], temp);\n\n    if(i !== 0){\n      // L-Befehl für eine Linie\n      path += \"L\" + coordinates[0] + \",\" + coordinates[1];\n    } else {\n      // Erster Punkt: M-Befehl für Anfangspunkt.\n      path += \"M\" + coordinates[0] + \",\" + coordinates[1];\n    }\n\n    if(i !== data.length - 1) {\n      path += \" \";\n    }\n  }\n  return path;\n}\n\nmodule.exports.update = function(data, index, value, v_accessor_scaled, v_accessor_cord) {\n    if(module.exports.mode == \"linear\" || module.exports.mode == \"undefined\"){\n      d3.select(\".line[data-row='\" + value.rowId + \"']\")\n       .attr(\"d\", module.exports.linear(data, v_accessor_cord(index, value)));\n    } else {\n      var line = d3.svg.line()\n        .x(index.accessor_scaled)\n        .y(v_accessor_scaled(value))\n        .interpolate(module.exports.mode);\n      d3.select(\".line[data-row='\" + value.rowId + \"']\")\n        .attr(\"d\", line(data));\n    }\n}\n\n\nmodule.exports.setActivated = function(activated, rowId, values){\n  var points_s = d3.selectAll(\".data-point[data-row='\"+rowId+\"']\");\n  var line = d3.selectAll(\".line[data-row='\"+rowId+\"']\");\n\n  line.classed(\"hidden\", !activated);\n\n  for(var i = 0; i<values.length; i++){\n    if(values[i].rowId == rowId){\n      values[i].activated = activated;\n    }\n  }\n\n  if(!activated){\n    // Nicht aktiviert: Override\n    points_s.classed(\"hidden\", !activated);\n  } else {\n    // Aktiviert: Zeigen, danach das Modul points entscheiden lassen.\n    points_s.classed(\"hidden\", !activated);\n    points.updateVisibility(values);\n  }\n\n}\n\n},{\"./points\":6}],6:[function(require,module,exports){\nmodule.exports.visible = false;\n\nmodule.exports.updateVisibility = function(values) {\n  for(var i = 0; i<values.length; i++){\n    var points = d3.selectAll(\".data-point[data-row='\"+values[i].rowId+\"']\");\n    console.log(values[i].activated);\n    if(module.exports.visible && values[i].activated) {\n      points.classed(\"hidden\", false);\n    } else {\n      points.classed(\"hidden\", true);\n    }\n  }\n}\n\n},{}],7:[function(require,module,exports){\n/**\n * Gibt das Minimum einer einzelnen Datenreihe zurück\n * @param  {[Array]} data     Der Datensatz\n * @param  {{Function}} index Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}         Das Minimum\n */\nmodule.exports.min = function(data, accessor) {\n  return d3.min(data, accessor);\n}\n\n/**\n * Gibt das Maximum einer einzelnen Datenreihe zurück\n * @param  {[Array]} data     Der Datensatz\n * @param  {{Function}} index Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}         Das Maximum\n */\nmodule.exports.max = function(data, accessor) {\n  return d3.max(data, accessor);\n}\n\n/**\n * Gibt das Minimum für mehrere Datensätze zurück.\n * @param  {[Array]} data           Der Datensatz\n * @param  {[Array]} values         Der Config-Array für die zu untersuchenden\n *                          \t\t\t\tDatenreihen.\n * @param  {{Function}} v_accessor  Die Funktion, die für eine bestimmte value-\n *                                  Reihe den Accessor zurückgibt.\n * @return {[Object]}               Das Minimum\n */\nmodule.exports.minMultipleSets = function(data, values, v_accessor) {\n  var min;\n  for(var i = 0; i<values.length; i++){\n    if(!values[i].activated) {\n      continue;\n    }\n    var lmin = d3.min(data, v_accessor(values[i]));\n    if(typeof lmin == \"undefined\"){\n      continue;\n    }\n    if(typeof min == \"undefined\" || lmin<min) {\n      min = lmin;\n    }\n  }\n  console.log(\"range min: \");\n  console.log(min);\n  return min;\n}\n\n/**\n * Gibt das Maximum für mehrere Datensätze zurück.\n * @param  {[Array]} data           Der Datensatz\n * @param  {[Array]} values         Der Config-Array für die zu untersuchenden Datenrei-\n *                                  hen.\n * @param  {{Function}} v_accessor  Die Funktion, die für eine bestimmte value-\n *                                   Reihe den Accessor zurückgibt.\n * @return {[Object]}               Das Maximum\n */\nmodule.exports.maxMultipleSets = function(data, values, v_accessor) {\n  var max;\n  for(var i = 0; i<values.length; i++){\n    if(!values[i].activated) {\n      continue;\n    }\n    var lmax = d3.max(data, v_accessor(values[i]));\n\n    if(typeof max == \"undefined\" || lmax>max) {\n      max = lmax;\n    }\n  }\n  console.log(\"range max:\");\n  console.log(max);\n  return max;\n}\n\n//  Wertebereich der Daten bestimmen mit d3: Um einen kleinen Abstand zwischen\n//  den maximalen Punkten und dem Ende des Rändern des Diagrammes zu bewahren,\n//  wird der Unterschied (Δ) des Minimums und dem untersuchten Wert mit 1.1\n//  mulitpliziert. Anschliessend wird die Summe des Minimums und des\n//  multiplizierten Wertes an d3 zurückgegeben.\n\n/**\n * Gibt die Summe der Minimums und des mit dem Faktor factor multiplizierten\n * Unterschied von min und max zurück.\n * Wird verwendet, damit oben und rechts von Graphen Platz ausgelassen wird.\n * @param  {[Number]} min       Minimum ohne Overflow\n * @param  {[Number]} max       Maximum ohne Overflow\n * @param  {[Number]} factor    Overflow-Faktor\n * @param  {{String}} data_type Der Datentyp von min und max\n * @return {[Number]}           Das Maximum mit Overflow.\n */\nmodule.exports.applyOverflow = function(min, max, factor, data_type) {\n  if(data_type == \"Date\") {\n    return new Date(min.getTime() + (max.getTime()-min.getTime()) * factor);\n  } else if(data_type == \"Number\") {\n    return min + (max-min) * factor;\n  }\n}\n\n},{}],8:[function(require,module,exports){\n/**\n * Array sortieren\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * @return {[type]} [description]\n */\nmodule.exports = function(data, index) {\n  data.sort(function(a, b) {\n    if (index.accessor(a) < index.accessor(b)) {\n      return -1;\n    }\n    if (index.accessor(a) > index.accessor(b)) {\n      return 1;\n    }\n    return 0;\n  });\n\n  return data;\n}\n\n},{}],9:[function(require,module,exports){\n/*******************************************************************************\n *\n *\n * Tooltip\n *\n *\n ******************************************************************************/\n\nconsole.log(\"Tooltip\");\n\n/**\n * Einstellungen für dieses Modul.\n * @type {Object}\n */\nmodule.exports.opt = {};\n\n/**\n * Findet den zu einem gegebenen Wert den nächsten in einem Array vorhandenem Wert.\n * @param  {[Array]} data         Datenset\n * @param  {[Function]} accessor  Funktion, das den zu vergleichenden Wert\n *                                zurückgibt, wenn das Objekt gegeben wird.\n * @param  {[type]} item          Der zu vergleichende Wert\n * @return {[Number]}             Der Index (0 < @return < data.length-1)\n */\nmodule.exports.nextIndex = function(data, accessor, item){\n  var index = -1;\n  for(var i = 0; i<data.length-1; i++){\n    // Liegt der Punkt zwischen zwei gegebenen Punkten?\n    var this_d = accessor(data[i]);\n    var next = accessor(data[i+1]);\n    var afterThis = item >=this_d;\n    var beforeNext = item <= next;\n\n    if(afterThis && beforeNext){\n      // Falls ja, setze 'index' auf den index des näheren Punktes.\n      Δ1 = Math.abs(accessor(data[i]) - item);\n      Δ2 = Math.abs(accessor(data[i+1]) - item);\n      index = Δ1 < Δ2 ? i : i + 1;\n    }\n  }\n  return index;\n}\n\n/**\n * Funktion für den Tooltip-Kreis und die Werteanzeige\n * @param  {[Array]} data           Datenarray\n * @param  {{String}} rowId       Name der Reihe\n * @param  {[Function]} accessor    Funktion, die das Koordinatenpaar den Punktes\n *                                \tzurückgibt.\n * @param  {[Number]} index         Index des Datenarray, die den zu \"tooltippenden\"\n *                                \tWert entspricht.\n * @param {{d3 View}} parent        d3-View, in das das Tooltip eingesetzt werden\n *                    \t\t\t\t\t\t\tsollte.\n * @param {{Function}} textAccessor Funktion, die den Text für das Tooltip zu-\n *                                  rückgibt.\n */\nmodule.exports.tooltip = function(data, rowId, accessor, index, parent, textAccessor, activated) {\n\n  // tooltip-Variablen\n  var tip = d3.select(\"#tooltip[data-row='\" + rowId + \"']\");\n  tip.classed(\"hidden\", !activated);\n\n  if(tip.empty()){\n    tip = parent.append(\"g\")\n      .attr(\"id\", \"tooltip\")\n      .attr(\"class\", \"tooltip\")\n      .attr(\"data-row\", rowId);\n\n    tip.append(\"circle\")\n      .attr(\"id\", \"tooltip-circle\");\n\n    var label = tip.append(\"g\")\n      .attr(\"id\", \"label\");\n\n    var text = label.append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"id\", \"label-text\");\n  }\n\n  if(index==-1){\n    tip.attr(\"visibility\", \"hidden\");\n    return;\n  }\n  tip.attr(\"visibility\", \"visible\");\n\n\n  tip.select(\"#label-text\")\n    .text(textAccessor(data[index]))\n    .attr(\"x\", 0)\n    .attr(\"y\", -10);\n\n  var cord = accessor(data[index]);\n  tip.attr(\"transform\", \"translate(\"+cord[0]+\",\"+cord[1]+\")\");\n}\n\n/**\n * Funktion, um den Ort des Tooltips neu zu berechnen (zum Beispiel wenn sich\n * die Maus bewegt oder gezoomt wird).\n * @param  {{Array}}    data        Der Datensatz zu der Visualisation\n * @param  {[d3 Scale]} xScale      Die x-Skala\n * @param  {[d3 Scale]} yScale      Die y-Skala\n * @param  {{Function}} index       Die Config für den Index\n * @param  {{Function}} values      Die Config für die Values\n */\nmodule.exports.updateTooltip = function(data, xScale, yScale, index, value, v_accessor, v_accessor_scaled, v_accessor_cord){\n  if(!module.exports.mouse){\n    return;\n  }\n  var x = module.exports.mouse[0]-module.exports.opt.graphTransform.xstart;\n\n  // Das interpolierte Datum berechnen\n  var x_date = xScale.invert(x);\n\n    // Den nächsten Index suchen.\n    var tooltipIndex = module.exports.nextIndex(data, index.accessor, x_date);\n\n    //tooltip\n    module.exports.tooltip(data, value.rowId, v_accessor_cord(index, value), tooltipIndex, d3.select(\"#graph\"), function(d) {\n      // Zahl runden\n      // http://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript\n      return Math.round(v_accessor(value)(d) * 1000) / 1000;\n    }, value.activated);\n\n}\n\n},{}],10:[function(require,module,exports){\nvar tooltip = require('./modules/tooltip');\nvar line = require('./modules/line');\nvar sort = require('./modules/sort');\nvar points = require('./modules/points');\nvar id = require('./modules/id');\nvar format = require('./modules/format');\nvar filter = require('./modules/filter');\nvar domain = require('./modules/domain');\n\n/*******************************************************************************\n *\n *\n * Initialisierung Visualisation\n *\n *\n ******************************************************************************/\n\n// Für die Visualisation benötigte Variablen\n\nvar config, datasetsMeta, datasets, index, values, v_accessor, v_acessor_scaled,\n  accessor_data, v_accessor_cord, xScale, yScale, w, h, graphTransform, mouse,\n  xAxis, yAxis, showPoints, xWertebereich, yWertebereich;\n\nshowPoints = false;\n\n/**\n * Laden der Konfigurationsdatei\n * @param  {[String]} \"meta.json\"             Der Dateiname für die\n *                                            Konfigurationsdatei\n * @param  {[Function]} function(err, config) Das Callback\n */\nd3.json(\"meta.json\", function(err, res) {\n  if(err) {\n    console.log(err);\n    alert(err);\n    return;\n  }\n\n  config = [];\n  datasetsMeta = res.datasets;\n\n  index = {};\n  values = [];\n\n  var colors = d3.scale.category20();\n\n  for(var i = 0; i<datasetsMeta.length; i++) {\n    var dataset = datasetsMeta[i];\n    var url = dataset.url;\n\n    for(var j = 0; j<dataset.config.length; j++){\n      var c = dataset.config[j];\n      c.url = url;\n\n      // Generiere id\n      c.rowId = id.get(c);\n\n      config.push(c);\n\n      // Einfügen der Config in index oder values\n      if(c.type == \"index\"){\n        index = c;\n      } else if(c.type == \"value\") {\n        // Spaltenspezifische Farbe generieren\n        c.color = colors(values.length+1);\n\n        // Wenn das Attribut activated nicht gesetzt ist, setze es auch true.\n        if(typeof c.activated == 'undefined') {\n          c.activated = true;\n        }\n        values.push(c);\n      }\n    }\n    // Bei unbekannten Typen: nicht in values oder index einfügen.\n  }\n\n  // Datentyp der Skalen festlegen\n  if(index.data_type==\"Number\") {\n    xScale = d3.scale.linear();\n  } else if(index.data_type==\"Date\") {\n    xScale = d3.time.scale();\n  }\n\n  if(values[0].data_type==\"Number\"){\n    yScale = d3.scale.linear();\n  } else if(values[0].data_type==\"Date\") {\n    yScale = d3.time.scale();\n  }\n\n\n\n  // Höhe und Breite des gesamten SVG-Elements definieren; Verschiebung des\n  // Graphs\n  w = 950;\n  h = 400;\n\n  graphTransform = {xstart: 70, ytop: 0, xend:0, ybottom:50};\n\n  // Das Tooltip über die Transformation benachrichtigen\n  tooltip.opt.graphTransform = graphTransform;\n\n  // Globale Maus-Variable initalisieren\n  mouse = [];\n\n  // Wertebereich der Achsenskalierungen definieren. Hier ist die Anzahl der Pixel\n  // gemeint, über die sich die Achsen erstrecken. Die x-Achse und die y-Achse\n  // verschieben wir um 50 nach rechts, damit man die y-Achse beschriften kann.\n  xScale.range([0,w - graphTransform.xstart - graphTransform.xend]);\n  yScale.range([h - graphTransform.ytop - graphTransform.ybottom, 0]);\n\n  // Die Achsen werden von d3 generiert.\n  xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\").ticks(5);\n  yAxis = d3.svg.axis().scale(yScale).orient(\"left\").ticks(5);\n\n  /*******************************************************************************\n   *\n   *\n   * Accessors für die Daten\n   *\n   *\n   ******************************************************************************/\n\n   index.accessor = function(d) {\n     return d[index.row];\n   };\n\n   index.accessor_scaled = function(d) {\n     return xScale(d[index.row]);\n   };\n\n   v_accessor = function(entry) {\n     return function(d) {\n       return d[entry.rowId];\n     };\n   };\n\n   v_accessor_scaled = function(entry) {\n     return function(d) {\n       return yScale(d[entry.rowId]);\n     }\n   };\n\n   v_accessor_cord = function(index, entry) {\n     return function(d) {\n       return [index.accessor_scaled(d), v_accessor_scaled(entry)(d)];\n     };\n   };\n\n   // Die Daten laden\n   loadFiles();\n});\n\n\n/*******************************************************************************\n *\n *\n * Laden der Daten\n *\n *\n ******************************************************************************/\n\n\n/**\n * Die Funktion, die den Datensatz lädt und vorbereitet.\n *\n * Vorgehen:  1. Laden der Daten\n * \t\t\t\t\t\t2. Formatieren des Datensatzes (data_types und id)\n * \t\t\t\t\t\t3. 'Mergen' mit den anderen Datensätzen, d. h. zusammenfügen\n * \t\t\t\t\t\t4. Sortieren\n * \t\t\t\t\t\t5. Die gemergten Datensätze weitergeben\n */\nfunction loadFiles() {\n\n  // Anzahl von Dateien, die schon heruntergeladen wurden\n  var loaded = 0;\n\n  // Die Variable für die gemergten Datensätze\n  var data = [];\n\n  // Jedes einzelne File herunterladen (1)\n  for(var i = 0; i<datasetsMeta.length; i++){\n    d3.csv(datasetsMeta[i].url, mkcb(i));\n  }\n\n  /**\n   * Funktion, die die Callback-Funktion für einen bestimmten Datensatz-Meta-\n   * daten-Objekt mit Index i zurückgibt. Siehe auch: MKCB-Problem.\n   * @param  {[Number]} i   Index des Datensatz-Metadaten-Objekts aus\n   *                        datasetsMeta.\n   * @return {[Function]}   Das generierte Callback, das nach dem Laden der\n   *                        Datei ausgeführt wird.\n   */\n  function mkcb(i) {return function(err, resp) {\n    if(err){\n      alert(err);\n      console.log(err);\n      return;\n    }\n\n    // Formatieren (2)\n    resp = format.data_types(resp, datasetsMeta[i].config);\n    resp = format.ids(resp, datasetsMeta[i].config);\n\n    // Merge (3)\n    for(var j = 0; j<resp.length; j++){\n      data.push(resp[j]);\n    }\n\n\n    if(++loaded == datasetsMeta.length){\n      // Alle Datein sind heruntergeladen worden und gemergt.\n\n      // Sortieren (4)\n      data = sort(data, index);\n\n      console.log(\"loaded\");\n\n      // Weitergeben (5)\n      loadVisualization(data);\n    }\n  };}\n}\n\n/*******************************************************************************\n *\n *\n * Laden der Visualisation\n *\n *\n ******************************************************************************/\n\n/**\n * Lädt die Visualisation\n * @param  {[type]} data  Die gemergten Datensätze\n */\nfunction loadVisualization(data) {\n\n  /**\n   *\n   *  Achsen initalisieren (d3)\n   *\n   */\n\n  xWertebereich = domain.overflowX(data, index, 1.1);\n  yWertebereich = domain.overflowY(data, values, v_accessor, 1.1);\n  xScale.domain(xWertebereich);\n  yScale.domain(yWertebereich);\n\n  /**\n   *\n   * Zoom (d3)\n   *\n   */\n\n  // Zoom hinzufügen\n  var zoom = d3.behavior.zoom()\n    .x(xScale)\n    .y(yScale)\n    .scaleExtent([0.9, 50])\n    .on(\"zoom\", draw);\n\n  // die variable graph initialiseren, damit sie in der Funktion zoomed() ver-\n  // wendet werden kann, obwohl sie erst später definiert wird.\n  var graph;\n\n  /**\n   * Wird aufgerufen, sobald gezoomt wurde.\n   */\n  function draw() {\n    // Achsen neu zeichnen\n    xAxisContainer.call(xAxis);\n    yAxisContainer.call(yAxis);\n\n    // Punkte neu berechnen.\n    for(var i = 0; i<values.length; i++) {\n      var p = v.selectAll(\"circle.data-point[data-row='\" + values[i].rowId + \"']\")\n        .attr(\"cx\", index.accessor_scaled)\n        .attr(\"cy\", v_accessor_scaled(values[i]));\n    }\n\n    // Tooltip, Linie bei Zoom aktualisieren\n    for(var i = 0; i<values.length; i++) {\n      tooltip.updateTooltip(filter.row(data, values[i].rowId), xScale, yScale, index, values[i], v_accessor, v_accessor_scaled, v_accessor_cord);\n      line.update(filter.row(data, values[i].rowId), index, values[i], v_accessor_scaled, v_accessor_cord);\n    }\n  }\n\n  /**\n   *\n   * Elemente einfügen\n   *\n   */\n\n  // SVG-Element mit id 'visualization' extrahieren aus html\n  var v = d3.select(\"#visualization\")\n    .attr(\"width\", w)\n    .attr(\"height\", h)\n\n  // Unterstützung für Zoom hinzufügen\n    .call(zoom);\n\n  // SVG-Maske für den Graph: Wir wollen nicht, dass Punkte aus unserem\n  // definierten Feld auftauchen. Siehe Masken-Problem.\n  v.append(\"mask\")\n    .attr(\"id\", \"mask\")\n    .append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n      .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n      .attr(\"fill\", \"white\");\n\n  // Container für die Visualisation hinzufügen und zu der Maske linken\n  graph = v.append(\"g\")\n    .attr(\"id\", \"graph\")\n    .attr(\"transform\", \"translate(\" + graphTransform.xstart +\n      \",\" + graphTransform.ytop + \")\")\n    .attr(\"mask\", \"url(#mask)\");\n\n  // Die Punkte zeichnen für jede Datenspalte (in values).\n  for(var i = 0; i<values.length; i++) {\n\n    // Die Punkte einer Spalte haben für das Attribut data-row die generierte id\n    // (siehe Identifikations-Problem)\n    var circles = graph.selectAll(\"circle[data-row='\"+values[i].rowId+\"']\")\n\n      // Aus dem gesamten gemergten Datensatz die Elemente extrahieren, die die\n      // entsprechende Reihe besitzen. Siehe Merge-Problem.\n      // Daten an Selektion binden, damit alle Aktionen an diesem Element für\n      // alle gebundenen Datenelemente ausgeführt werden.\n      .data(filter.row(data, values[i].rowId)).enter();\n\n    // Aktionen an Datengebundener Selektion ausführen\n    circles.append(\"circle\")\n        .attr(\"class\", \"data-point\")\n        .attr(\"data-row\", values[i].rowId)\n        .attr(\"cx\", index.accessor_scaled)\n        .attr(\"cy\", v_accessor_scaled(values[i]));\n  }\n\n  // Sichtbarkeit der Punkte prüfen\n  points.updateVisibility(values);\n\n  /**\n   *\n   * d3-Achsen einfügen\n   *\n   */\n\n  var xAxisContainer = v.append(\"g\")\n    .attr(\"class\", \"axis axis-x\")\n    .attr(\"transform\", \"translate(\" +\n      graphTransform.xstart + \",\" +\n      (h - graphTransform.ybottom) + \")\")\n    .call(xAxis);\n\n  var yAxisContainer = v.append(\"g\")\n    .attr(\"class\", \"axis axis-y\")\n    .attr(\"transform\", \"translate(\"+graphTransform.xstart+\",0)\")\n    .call(yAxis);\n\n  /**\n   *\n   * Tooltip (nicht von d3, selber implementiert)\n   *\n   */\n\n  // Maus-Koordinaten: Um auf die Maus-Koordinaten zugreifen zu können, muss man\n  // ein unsichtbares Element über den gesamten Graph legen, der alle\n  // 'Maus-Events' \"aufnimmt\". Ein leerer g-SVG-Container (wie 'graph') ist\n  // nicht fähig, Maus-Events aufzunehmen. Siehe Event-Problem.\n  v.append(\"rect\")\n    .attr(\"id\", \"overlay\")\n    .attr(\"x\", graphTransform.xstart)\n    .attr(\"y\", graphTransform.ytop)\n    .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n    .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n    .on(\"mousemove\", function() {\n      tooltip.mouse = d3.mouse(this);\n      for(var i = 0; i<values.length; i++) {\n        tooltip.updateTooltip(filter.row(data, values[i].rowId), xScale, yScale,\n          index, values[i], v_accessor, v_accessor_scaled, v_accessor_cord);\n      }\n    });\n\n  /**\n   *\n   * Linien\n   *\n   */\n\n   for(var i = 0; i<values.length; i++) {\n      line.addLine(index, values[i], filter.row(data, values[i].rowId), v_accessor_cord(index, values[i]));\n   }\n\n   $('select').on('change', function() {\n     line.mode = this.value;\n     for(var i = 0; i<values.length; i++){\n       line.update(filter.row(data, values[i].rowId), index, values[i], v_accessor_scaled, v_accessor_cord);\n     }\n   });\n\n   $('#checkbox').on('change', function() {\n     if($(this).is(\":checked\")){\n       showPoints = true;\n     } else {\n       showPoints = false;\n      }\n      points.visible = showPoints;\n      points.updateVisibility(values);\n   });\n\n   /**\n    *\n    * Toggles\n    *\n    */\n\n   // Funktion, um den y-Wertebereich bei einem Toggle zu aktualisieren und die\n   // y-Skalierung\n   function updateDomain() {\n     zoom.scale(1);\n     zoom.translate([0,0]);\n\n     yWertebereich = domain.overflowY(data, values, v_accessor, 1.1);\n     yScale.domain(yWertebereich);\n     zoom.y(yScale)\n     yAxis.scale(yScale);\n     draw();\n   }\n\n    for(var i = 0; i<values.length; i++){\n      d3.select(\"#select-row\")\n        .append(\"p\")\n        .attr(\"class\", \"select-row-item\")\n        .classed(\"inactive\", !values[i].activated)\n        .attr(\"style\", \"border-color:\"+values[i].color)\n        .attr(\"data-row\", values[i].rowId)\n        .text(values[i].name ? values[i].name : values[i].row);\n\n      line.setActivated(values[i].activated, values[i].rowId, values);\n\n      $(\".select-row-item[data-row='\" + values[i].rowId + \"']\").on('click', function() {\n        var row = $(this).attr(\"data-row\");\n        var value = id.invert(row, values);\n\n        if($(this).hasClass(\"inactive\")){\n          // activate this\n          $(this).toggleClass(\"inactive\", false);\n          line.setActivated(true, row, values);\n          value.activated = true;\n        } else {\n          // deactivate this\n          $(this).toggleClass(\"inactive\", true);\n          line.setActivated(false, row, values);\n          value.activated = false;\n        }\n\n        updateDomain();\n      });\n    }\n}\n\n},{\"./modules/domain\":1,\"./modules/filter\":2,\"./modules/format\":3,\"./modules/id\":4,\"./modules/line\":5,\"./modules/points\":6,\"./modules/sort\":8,\"./modules/tooltip\":9}]},{},[10])\n\n","module.exports.row = function(data, row) {\n  var ret = [];\n  for(var i = 0; i<data.length; i++){\n    if(typeof data[i][row] !== \"undefined\"){\n      ret.push(data[i]);\n    }\n  }\n  return ret;\n}\n","var sort = require('./sort');\nvar id = require('./id');\n\nmodule.exports.data_types = function(data, config) {\n  // index suchen\n  for(var i = 0; i<data.length; i++) {\n    for(var j = 0; j<config.length; j++) {\n      if(config[j].data_type == \"Number\") {\n        data[i][config[j].row] = parseFloat(data[i][config[j].row]);\n      } else if(config[j].data_type == \"Date\") {\n        data[i][config[j].row] =  d3.time.format(config[j].date_format)\n                                    .parse(data[i][config[j].row]);\n      }\n    }\n  }\n  return data;\n}\n\nmodule.exports.ids = function(data, config) {\n  console.log(data);\n  console.log(config);\n\n  for(var i = 0; i<data.length; i++) {\n    for(var j = 0; j<config.length; j++){\n      if(config[j].type == \"index\"){\n        continue;\n      }\n      data[i][id.get(config[j])] = data[i][config[j].row];\n      delete data[i][config[j].row];\n    }\n  }\n\n  return data;\n}\n","module.exports.get = function(config) {\n  return config.row + \"#\" + config.url;\n}\n\n// ret value config obj\nmodule.exports.invert = function(id, values) {\n  for(var i = 0; i<values.length; i++) {\n    if(id == values[i].rowId) {\n      return values[i];\n    }\n  }\n}\n\nmodule.exports.raw = function(attr, url) {\n  return attr+\"#\"+url;\n}\n","var points = require(\"./points\");\n\n/**\n * Html-Element select zur Auswahl des Modus: Die Variable 'mode' bei\n * Änderung aktualisieren.\n *\n * Checkbox 'Punkte anzeigen': Die Datenpunkte anzeigen / verstecken.\n */\n\nmodule.exports.mode = \"undefined\";\n\n/**\n * Fügt eine Linie hinzu.\n * @param  {[Object]} index  Die Config des Indexes.\n * @param  {[Object]} config Die Config der betreffenden Spalte.\n */\nmodule.exports.addLine = function(index, config, data, accessor_cord) {\n  var path = d3.select(\"#graph\")\n   .append(\"path\")\n   .attr(\"class\", \"line\")\n   .attr(\"style\", \"stroke:\"+config.color)\n   .attr(\"data-row\", config.rowId);\n\n   if(module.exports.mode == \"linear\" || module.exports.mode == \"undefined\"){\n      path.attr(\"d\", module.exports.linear(data, accessor_cord));\n   } else {\n     var line = d3.svg.line()\n       .x(accessor_scaled_x)\n       .y(accessor_scaled_y)\n       .interpolate(module.exports.mode);\n   }\n}\n\n/**\n * Gibt die Lineare Interpolation als SVG-Path-String zurück\n * @param  {[Array]} data        Das Datenarray\n * @param  {{Function}} accessor Die Funktion, welche die Koordinaten zurück-\n *                               gibt des entsprechenden Punktes\n * @return {[String]}            String, das in das Attribut 'd' im path-\n *                               Element eingesetzt werden muss.\n */\nmodule.exports.linear = function(data, accessor) {\n  var path = \"\";\n\n  //figure out\n  var temp = \"Weighted Price\";\n\n  for(var i = 0; i < data.length; i++) {\n    var coordinates = accessor(data[i], temp);\n\n    if(i !== 0){\n      // L-Befehl für eine Linie\n      path += \"L\" + coordinates[0] + \",\" + coordinates[1];\n    } else {\n      // Erster Punkt: M-Befehl für Anfangspunkt.\n      path += \"M\" + coordinates[0] + \",\" + coordinates[1];\n    }\n\n    if(i !== data.length - 1) {\n      path += \" \";\n    }\n  }\n  return path;\n}\n\nmodule.exports.update = function(data, index, value, v_accessor_scaled, v_accessor_cord) {\n    if(module.exports.mode == \"linear\" || module.exports.mode == \"undefined\"){\n      d3.select(\".line[data-row='\" + value.rowId + \"']\")\n       .attr(\"d\", module.exports.linear(data, v_accessor_cord(index, value)));\n    } else {\n      var line = d3.svg.line()\n        .x(index.accessor_scaled)\n        .y(v_accessor_scaled(value))\n        .interpolate(module.exports.mode);\n      d3.select(\".line[data-row='\" + value.rowId + \"']\")\n        .attr(\"d\", line(data));\n    }\n}\n\n\nmodule.exports.setActivated = function(activated, rowId, values){\n  var points_s = d3.selectAll(\".data-point[data-row='\"+rowId+\"']\");\n  var line = d3.selectAll(\".line[data-row='\"+rowId+\"']\");\n\n  line.classed(\"hidden\", !activated);\n\n  for(var i = 0; i<values.length; i++){\n    if(values[i].rowId == rowId){\n      values[i].activated = activated;\n    }\n  }\n\n  if(!activated){\n    // Nicht aktiviert: Override\n    points_s.classed(\"hidden\", !activated);\n  } else {\n    // Aktiviert: Zeigen, danach das Modul points entscheiden lassen.\n    points_s.classed(\"hidden\", !activated);\n    points.updateVisibility(values);\n  }\n\n}\n","module.exports.visible = false;\n\nmodule.exports.updateVisibility = function(values) {\n  for(var i = 0; i<values.length; i++){\n    var points = d3.selectAll(\".data-point[data-row='\"+values[i].rowId+\"']\");\n    console.log(values[i].activated);\n    if(module.exports.visible && values[i].activated) {\n      points.classed(\"hidden\", false);\n    } else {\n      points.classed(\"hidden\", true);\n    }\n  }\n}\n","/**\n * Gibt das Minimum einer einzelnen Datenreihe zurück\n * @param  {[Array]} data     Der Datensatz\n * @param  {{Function}} index Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}         Das Minimum\n */\nmodule.exports.min = function(data, accessor) {\n  return d3.min(data, accessor);\n}\n\n/**\n * Gibt das Maximum einer einzelnen Datenreihe zurück\n * @param  {[Array]} data     Der Datensatz\n * @param  {{Function}} index Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}         Das Maximum\n */\nmodule.exports.max = function(data, accessor) {\n  return d3.max(data, accessor);\n}\n\n/**\n * Gibt das Minimum für mehrere Datensätze zurück.\n * @param  {[Array]} data           Der Datensatz\n * @param  {[Array]} values         Der Config-Array für die zu untersuchenden\n *                          \t\t\t\tDatenreihen.\n * @param  {{Function}} v_accessor  Die Funktion, die für eine bestimmte value-\n *                                  Reihe den Accessor zurückgibt.\n * @return {[Object]}               Das Minimum\n */\nmodule.exports.minMultipleSets = function(data, values, v_accessor) {\n  var min;\n  for(var i = 0; i<values.length; i++){\n    if(!values[i].activated) {\n      continue;\n    }\n    var lmin = d3.min(data, v_accessor(values[i]));\n    if(typeof lmin == \"undefined\"){\n      continue;\n    }\n    if(typeof min == \"undefined\" || lmin<min) {\n      min = lmin;\n    }\n  }\n  console.log(\"range min: \");\n  console.log(min);\n  return min;\n}\n\n/**\n * Gibt das Maximum für mehrere Datensätze zurück.\n * @param  {[Array]} data           Der Datensatz\n * @param  {[Array]} values         Der Config-Array für die zu untersuchenden Datenrei-\n *                                  hen.\n * @param  {{Function}} v_accessor  Die Funktion, die für eine bestimmte value-\n *                                   Reihe den Accessor zurückgibt.\n * @return {[Object]}               Das Maximum\n */\nmodule.exports.maxMultipleSets = function(data, values, v_accessor) {\n  var max;\n  for(var i = 0; i<values.length; i++){\n    if(!values[i].activated) {\n      continue;\n    }\n    var lmax = d3.max(data, v_accessor(values[i]));\n\n    if(typeof max == \"undefined\" || lmax>max) {\n      max = lmax;\n    }\n  }\n  console.log(\"range max:\");\n  console.log(max);\n  return max;\n}\n\n//  Wertebereich der Daten bestimmen mit d3: Um einen kleinen Abstand zwischen\n//  den maximalen Punkten und dem Ende des Rändern des Diagrammes zu bewahren,\n//  wird der Unterschied (Δ) des Minimums und dem untersuchten Wert mit 1.1\n//  mulitpliziert. Anschliessend wird die Summe des Minimums und des\n//  multiplizierten Wertes an d3 zurückgegeben.\n\n/**\n * Gibt die Summe der Minimums und des mit dem Faktor factor multiplizierten\n * Unterschied von min und max zurück.\n * Wird verwendet, damit oben und rechts von Graphen Platz ausgelassen wird.\n * @param  {[Number]} min       Minimum ohne Overflow\n * @param  {[Number]} max       Maximum ohne Overflow\n * @param  {[Number]} factor    Overflow-Faktor\n * @param  {{String}} data_type Der Datentyp von min und max\n * @return {[Number]}           Das Maximum mit Overflow.\n */\nmodule.exports.applyOverflow = function(min, max, factor, data_type) {\n  if(data_type == \"Date\") {\n    return new Date(min.getTime() + (max.getTime()-min.getTime()) * factor);\n  } else if(data_type == \"Number\") {\n    return min + (max-min) * factor;\n  }\n}\n","/**\n * Array sortieren\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * @return {[type]} [description]\n */\nmodule.exports = function(data, index) {\n  data.sort(function(a, b) {\n    if (index.accessor(a) < index.accessor(b)) {\n      return -1;\n    }\n    if (index.accessor(a) > index.accessor(b)) {\n      return 1;\n    }\n    return 0;\n  });\n\n  return data;\n}\n","/*******************************************************************************\n *\n *\n * Tooltip\n *\n *\n ******************************************************************************/\n\nconsole.log(\"Tooltip\");\n\n/**\n * Einstellungen für dieses Modul.\n * @type {Object}\n */\nmodule.exports.opt = {};\n\n/**\n * Findet den zu einem gegebenen Wert den nächsten in einem Array vorhandenem Wert.\n * @param  {[Array]} data         Datenset\n * @param  {[Function]} accessor  Funktion, das den zu vergleichenden Wert\n *                                zurückgibt, wenn das Objekt gegeben wird.\n * @param  {[type]} item          Der zu vergleichende Wert\n * @return {[Number]}             Der Index (0 < @return < data.length-1)\n */\nmodule.exports.nextIndex = function(data, accessor, item){\n  var index = -1;\n  for(var i = 0; i<data.length-1; i++){\n    // Liegt der Punkt zwischen zwei gegebenen Punkten?\n    var this_d = accessor(data[i]);\n    var next = accessor(data[i+1]);\n    var afterThis = item >=this_d;\n    var beforeNext = item <= next;\n\n    if(afterThis && beforeNext){\n      // Falls ja, setze 'index' auf den index des näheren Punktes.\n      Δ1 = Math.abs(accessor(data[i]) - item);\n      Δ2 = Math.abs(accessor(data[i+1]) - item);\n      index = Δ1 < Δ2 ? i : i + 1;\n    }\n  }\n  return index;\n}\n\n/**\n * Funktion für den Tooltip-Kreis und die Werteanzeige\n * @param  {[Array]} data           Datenarray\n * @param  {{String}} rowId       Name der Reihe\n * @param  {[Function]} accessor    Funktion, die das Koordinatenpaar den Punktes\n *                                \tzurückgibt.\n * @param  {[Number]} index         Index des Datenarray, die den zu \"tooltippenden\"\n *                                \tWert entspricht.\n * @param {{d3 View}} parent        d3-View, in das das Tooltip eingesetzt werden\n *                    \t\t\t\t\t\t\tsollte.\n * @param {{Function}} textAccessor Funktion, die den Text für das Tooltip zu-\n *                                  rückgibt.\n */\nmodule.exports.tooltip = function(data, rowId, accessor, index, parent, textAccessor, activated) {\n\n  // tooltip-Variablen\n  var tip = d3.select(\"#tooltip[data-row='\" + rowId + \"']\");\n  tip.classed(\"hidden\", !activated);\n\n  if(tip.empty()){\n    tip = parent.append(\"g\")\n      .attr(\"id\", \"tooltip\")\n      .attr(\"class\", \"tooltip\")\n      .attr(\"data-row\", rowId);\n\n    tip.append(\"circle\")\n      .attr(\"id\", \"tooltip-circle\");\n\n    var label = tip.append(\"g\")\n      .attr(\"id\", \"label\");\n\n    var text = label.append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"id\", \"label-text\");\n  }\n\n  if(index==-1){\n    tip.attr(\"visibility\", \"hidden\");\n    return;\n  }\n  tip.attr(\"visibility\", \"visible\");\n\n\n  tip.select(\"#label-text\")\n    .text(textAccessor(data[index]))\n    .attr(\"x\", 0)\n    .attr(\"y\", -10);\n\n  var cord = accessor(data[index]);\n  tip.attr(\"transform\", \"translate(\"+cord[0]+\",\"+cord[1]+\")\");\n}\n\n/**\n * Funktion, um den Ort des Tooltips neu zu berechnen (zum Beispiel wenn sich\n * die Maus bewegt oder gezoomt wird).\n * @param  {{Array}}    data        Der Datensatz zu der Visualisation\n * @param  {[d3 Scale]} xScale      Die x-Skala\n * @param  {[d3 Scale]} yScale      Die y-Skala\n * @param  {{Function}} index       Die Config für den Index\n * @param  {{Function}} values      Die Config für die Values\n */\nmodule.exports.updateTooltip = function(data, xScale, yScale, index, value, v_accessor, v_accessor_scaled, v_accessor_cord){\n  if(!module.exports.mouse){\n    return;\n  }\n  var x = module.exports.mouse[0]-module.exports.opt.graphTransform.xstart;\n\n  // Das interpolierte Datum berechnen\n  var x_date = xScale.invert(x);\n\n    // Den nächsten Index suchen.\n    var tooltipIndex = module.exports.nextIndex(data, index.accessor, x_date);\n\n    //tooltip\n    module.exports.tooltip(data, value.rowId, v_accessor_cord(index, value), tooltipIndex, d3.select(\"#graph\"), function(d) {\n      // Zahl runden\n      // http://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript\n      return Math.round(v_accessor(value)(d) * 1000) / 1000;\n    }, value.activated);\n\n}\n","var tooltip = require('./modules/tooltip');\nvar line = require('./modules/line');\nvar sort = require('./modules/sort');\nvar points = require('./modules/points');\nvar id = require('./modules/id');\nvar format = require('./modules/format');\nvar filter = require('./modules/filter');\nvar domain = require('./modules/domain');\n\n/*******************************************************************************\n *\n *\n * Initialisierung Visualisation\n *\n *\n ******************************************************************************/\n\n// Für die Visualisation benötigte Variablen\n\nvar config, datasetsMeta, datasets, index, values, v_accessor, v_acessor_scaled,\n  accessor_data, v_accessor_cord, xScale, yScale, w, h, graphTransform, mouse,\n  xAxis, yAxis, showPoints, xWertebereich, yWertebereich;\n\nshowPoints = false;\n\n/**\n * Laden der Konfigurationsdatei\n * @param  {[String]} \"meta.json\"             Der Dateiname für die\n *                                            Konfigurationsdatei\n * @param  {[Function]} function(err, config) Das Callback\n */\nd3.json(\"meta.json\", function(err, res) {\n  if(err) {\n    console.log(err);\n    alert(err);\n    return;\n  }\n\n  config = [];\n  datasetsMeta = res.datasets;\n\n  index = {};\n  values = [];\n\n  var colors = d3.scale.category20();\n\n  for(var i = 0; i<datasetsMeta.length; i++) {\n    var dataset = datasetsMeta[i];\n    var url = dataset.url;\n\n    for(var j = 0; j<dataset.config.length; j++){\n      var c = dataset.config[j];\n      c.url = url;\n\n      // Generiere id\n      c.rowId = id.get(c);\n\n      config.push(c);\n\n      // Einfügen der Config in index oder values\n      if(c.type == \"index\"){\n        index = c;\n      } else if(c.type == \"value\") {\n        // Spaltenspezifische Farbe generieren\n        c.color = colors(values.length+1);\n\n        // Wenn das Attribut activated nicht gesetzt ist, setze es auch true.\n        if(typeof c.activated == 'undefined') {\n          c.activated = true;\n        }\n        values.push(c);\n      }\n    }\n    // Bei unbekannten Typen: nicht in values oder index einfügen.\n  }\n\n  // Datentyp der Skalen festlegen\n  if(index.data_type==\"Number\") {\n    xScale = d3.scale.linear();\n  } else if(index.data_type==\"Date\") {\n    xScale = d3.time.scale();\n  }\n\n  if(values[0].data_type==\"Number\"){\n    yScale = d3.scale.linear();\n  } else if(values[0].data_type==\"Date\") {\n    yScale = d3.time.scale();\n  }\n\n\n\n  // Höhe und Breite des gesamten SVG-Elements definieren; Verschiebung des\n  // Graphs\n  w = 950;\n  h = 400;\n\n  graphTransform = {xstart: 70, ytop: 0, xend:0, ybottom:50};\n\n  // Das Tooltip über die Transformation benachrichtigen\n  tooltip.opt.graphTransform = graphTransform;\n\n  // Globale Maus-Variable initalisieren\n  mouse = [];\n\n  // Wertebereich der Achsenskalierungen definieren. Hier ist die Anzahl der Pixel\n  // gemeint, über die sich die Achsen erstrecken. Die x-Achse und die y-Achse\n  // verschieben wir um 50 nach rechts, damit man die y-Achse beschriften kann.\n  xScale.range([0,w - graphTransform.xstart - graphTransform.xend]);\n  yScale.range([h - graphTransform.ytop - graphTransform.ybottom, 0]);\n\n  // Die Achsen werden von d3 generiert.\n  xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\").ticks(5);\n  yAxis = d3.svg.axis().scale(yScale).orient(\"left\").ticks(5);\n\n  /*******************************************************************************\n   *\n   *\n   * Accessors für die Daten\n   *\n   *\n   ******************************************************************************/\n\n   index.accessor = function(d) {\n     return d[index.row];\n   };\n\n   index.accessor_scaled = function(d) {\n     return xScale(d[index.row]);\n   };\n\n   v_accessor = function(entry) {\n     return function(d) {\n       return d[entry.rowId];\n     };\n   };\n\n   v_accessor_scaled = function(entry) {\n     return function(d) {\n       return yScale(d[entry.rowId]);\n     }\n   };\n\n   v_accessor_cord = function(index, entry) {\n     return function(d) {\n       return [index.accessor_scaled(d), v_accessor_scaled(entry)(d)];\n     };\n   };\n\n   // Die Daten laden\n   loadFiles();\n});\n\n\n/*******************************************************************************\n *\n *\n * Laden der Daten\n *\n *\n ******************************************************************************/\n\n\n/**\n * Die Funktion, die den Datensatz lädt und vorbereitet.\n *\n * Vorgehen:  1. Laden der Daten\n * \t\t\t\t\t\t2. Formatieren des Datensatzes (data_types und id)\n * \t\t\t\t\t\t3. 'Mergen' mit den anderen Datensätzen, d. h. zusammenfügen\n * \t\t\t\t\t\t4. Sortieren\n * \t\t\t\t\t\t5. Die gemergten Datensätze weitergeben\n */\nfunction loadFiles() {\n\n  // Anzahl von Dateien, die schon heruntergeladen wurden\n  var loaded = 0;\n\n  // Die Variable für die gemergten Datensätze\n  var data = [];\n\n  // Jedes einzelne File herunterladen (1)\n  for(var i = 0; i<datasetsMeta.length; i++){\n    d3.csv(datasetsMeta[i].url, mkcb(i));\n  }\n\n  /**\n   * Funktion, die die Callback-Funktion für einen bestimmten Datensatz-Meta-\n   * daten-Objekt mit Index i zurückgibt. Siehe auch: MKCB-Problem.\n   * @param  {[Number]} i   Index des Datensatz-Metadaten-Objekts aus\n   *                        datasetsMeta.\n   * @return {[Function]}   Das generierte Callback, das nach dem Laden der\n   *                        Datei ausgeführt wird.\n   */\n  function mkcb(i) {return function(err, resp) {\n    if(err){\n      alert(err);\n      console.log(err);\n      return;\n    }\n\n    // Formatieren (2)\n    resp = format.data_types(resp, datasetsMeta[i].config);\n    resp = format.ids(resp, datasetsMeta[i].config);\n\n    // Merge (3)\n    for(var j = 0; j<resp.length; j++){\n      data.push(resp[j]);\n    }\n\n\n    if(++loaded == datasetsMeta.length){\n      // Alle Datein sind heruntergeladen worden und gemergt.\n\n      // Sortieren (4)\n      data = sort(data, index);\n\n      console.log(\"loaded\");\n\n      // Weitergeben (5)\n      loadVisualization(data);\n    }\n  };}\n}\n\n/*******************************************************************************\n *\n *\n * Laden der Visualisation\n *\n *\n ******************************************************************************/\n\n/**\n * Lädt die Visualisation\n * @param  {[type]} data  Die gemergten Datensätze\n */\nfunction loadVisualization(data) {\n\n  /**\n   *\n   *  Achsen initalisieren (d3)\n   *\n   */\n\n  xWertebereich = domain.overflowX(data, index, 1.1);\n  yWertebereich = domain.overflowY(data, values, v_accessor, 1.1);\n  xScale.domain(xWertebereich);\n  yScale.domain(yWertebereich);\n\n  /**\n   *\n   * Zoom (d3)\n   *\n   */\n\n  // Zoom hinzufügen\n  var zoom = d3.behavior.zoom()\n    .x(xScale)\n    .y(yScale)\n    .scaleExtent([0.9, 50])\n    .on(\"zoom\", draw);\n\n  // die variable graph initialiseren, damit sie in der Funktion zoomed() ver-\n  // wendet werden kann, obwohl sie erst später definiert wird.\n  var graph;\n\n  /**\n   * Wird aufgerufen, sobald gezoomt wurde.\n   */\n  function draw() {\n    // Achsen neu zeichnen\n    xAxisContainer.call(xAxis);\n    yAxisContainer.call(yAxis);\n\n    // Punkte neu berechnen.\n    for(var i = 0; i<values.length; i++) {\n      var p = v.selectAll(\"circle.data-point[data-row='\" + values[i].rowId + \"']\")\n        .attr(\"cx\", index.accessor_scaled)\n        .attr(\"cy\", v_accessor_scaled(values[i]));\n    }\n\n    // Tooltip, Linie bei Zoom aktualisieren\n    for(var i = 0; i<values.length; i++) {\n      tooltip.updateTooltip(filter.row(data, values[i].rowId), xScale, yScale, index, values[i], v_accessor, v_accessor_scaled, v_accessor_cord);\n      line.update(filter.row(data, values[i].rowId), index, values[i], v_accessor_scaled, v_accessor_cord);\n    }\n  }\n\n  /**\n   *\n   * Elemente einfügen\n   *\n   */\n\n  // SVG-Element mit id 'visualization' extrahieren aus html\n  var v = d3.select(\"#visualization\")\n    .attr(\"width\", w)\n    .attr(\"height\", h)\n\n  // Unterstützung für Zoom hinzufügen\n    .call(zoom);\n\n  // SVG-Maske für den Graph: Wir wollen nicht, dass Punkte aus unserem\n  // definierten Feld auftauchen. Siehe Masken-Problem.\n  v.append(\"mask\")\n    .attr(\"id\", \"mask\")\n    .append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n      .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n      .attr(\"fill\", \"white\");\n\n  // Container für die Visualisation hinzufügen und zu der Maske linken\n  graph = v.append(\"g\")\n    .attr(\"id\", \"graph\")\n    .attr(\"transform\", \"translate(\" + graphTransform.xstart +\n      \",\" + graphTransform.ytop + \")\")\n    .attr(\"mask\", \"url(#mask)\");\n\n  // Die Punkte zeichnen für jede Datenspalte (in values).\n  for(var i = 0; i<values.length; i++) {\n\n    // Die Punkte einer Spalte haben für das Attribut data-row die generierte id\n    // (siehe Identifikations-Problem)\n    var circles = graph.selectAll(\"circle[data-row='\"+values[i].rowId+\"']\")\n\n      // Aus dem gesamten gemergten Datensatz die Elemente extrahieren, die die\n      // entsprechende Reihe besitzen. Siehe Merge-Problem.\n      // Daten an Selektion binden, damit alle Aktionen an diesem Element für\n      // alle gebundenen Datenelemente ausgeführt werden.\n      .data(filter.row(data, values[i].rowId)).enter();\n\n    // Aktionen an Datengebundener Selektion ausführen\n    circles.append(\"circle\")\n        .attr(\"class\", \"data-point\")\n        .attr(\"data-row\", values[i].rowId)\n        .attr(\"cx\", index.accessor_scaled)\n        .attr(\"cy\", v_accessor_scaled(values[i]));\n  }\n\n  // Sichtbarkeit der Punkte prüfen\n  points.updateVisibility(values);\n\n  /**\n   *\n   * d3-Achsen einfügen\n   *\n   */\n\n  var xAxisContainer = v.append(\"g\")\n    .attr(\"class\", \"axis axis-x\")\n    .attr(\"transform\", \"translate(\" +\n      graphTransform.xstart + \",\" +\n      (h - graphTransform.ybottom) + \")\")\n    .call(xAxis);\n\n  var yAxisContainer = v.append(\"g\")\n    .attr(\"class\", \"axis axis-y\")\n    .attr(\"transform\", \"translate(\"+graphTransform.xstart+\",0)\")\n    .call(yAxis);\n\n  /**\n   *\n   * Tooltip (nicht von d3, selber implementiert)\n   *\n   */\n\n  // Maus-Koordinaten: Um auf die Maus-Koordinaten zugreifen zu können, muss man\n  // ein unsichtbares Element über den gesamten Graph legen, der alle\n  // 'Maus-Events' \"aufnimmt\". Ein leerer g-SVG-Container (wie 'graph') ist\n  // nicht fähig, Maus-Events aufzunehmen. Siehe Event-Problem.\n  v.append(\"rect\")\n    .attr(\"id\", \"overlay\")\n    .attr(\"x\", graphTransform.xstart)\n    .attr(\"y\", graphTransform.ytop)\n    .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n    .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n    .on(\"mousemove\", function() {\n      tooltip.mouse = d3.mouse(this);\n      for(var i = 0; i<values.length; i++) {\n        tooltip.updateTooltip(filter.row(data, values[i].rowId), xScale, yScale,\n          index, values[i], v_accessor, v_accessor_scaled, v_accessor_cord);\n      }\n    });\n\n  /**\n   *\n   * Linien\n   *\n   */\n\n   for(var i = 0; i<values.length; i++) {\n      line.addLine(index, values[i], filter.row(data, values[i].rowId), v_accessor_cord(index, values[i]));\n   }\n\n   $('select').on('change', function() {\n     line.mode = this.value;\n     for(var i = 0; i<values.length; i++){\n       line.update(filter.row(data, values[i].rowId), index, values[i], v_accessor_scaled, v_accessor_cord);\n     }\n   });\n\n   $('#checkbox').on('change', function() {\n     if($(this).is(\":checked\")){\n       showPoints = true;\n     } else {\n       showPoints = false;\n      }\n      points.visible = showPoints;\n      points.updateVisibility(values);\n   });\n\n   /**\n    *\n    * Toggles\n    *\n    */\n\n   // Funktion, um den y-Wertebereich bei einem Toggle zu aktualisieren und die\n   // y-Skalierung\n   function updateDomain() {\n     zoom.scale(1);\n     zoom.translate([0,0]);\n\n     yWertebereich = domain.overflowY(data, values, v_accessor, 1.1);\n     yScale.domain(yWertebereich);\n     zoom.y(yScale)\n     yAxis.scale(yScale);\n     draw();\n   }\n\n    for(var i = 0; i<values.length; i++){\n      d3.select(\"#select-row\")\n        .append(\"p\")\n        .attr(\"class\", \"select-row-item\")\n        .classed(\"inactive\", !values[i].activated)\n        .attr(\"style\", \"border-color:\"+values[i].color)\n        .attr(\"data-row\", values[i].rowId)\n        .text(values[i].name ? values[i].name : values[i].row);\n\n      line.setActivated(values[i].activated, values[i].rowId, values);\n\n      $(\".select-row-item[data-row='\" + values[i].rowId + \"']\").on('click', function() {\n        var row = $(this).attr(\"data-row\");\n        var value = id.invert(row, values);\n\n        if($(this).hasClass(\"inactive\")){\n          // activate this\n          $(this).toggleClass(\"inactive\", false);\n          line.setActivated(true, row, values);\n          value.activated = true;\n        } else {\n          // deactivate this\n          $(this).toggleClass(\"inactive\", true);\n          line.setActivated(false, row, values);\n          value.activated = false;\n        }\n\n        updateDomain();\n      });\n    }\n}\n"],"sourceRoot":"/source/"}