{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","tests/unified/modules/line.js","script.js","tests/unified/modules/range.js","tests/unified/modules/sort.js","tests/unified/modules/tooltip.js","tests/unified/script.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","mode","addLine","index","config","data","accessor_cord","path","d3","select","append","attr","linear","svg","line","x","accessor_scaled_x","y","accessor_scaled_y","interpolate","accessor","temp","coordinates","update","values","accessor_scaled",2,"min","max","minMultipleSets","lmin","maxMultipleSets","lmax","applyOverflow","factor","data_type","Date","getTime",3,"sort","b",4,"console","log","opt","nextIndex","item","this_d","next","afterThis","beforeNext","Δ1","Math","abs","Δ2","tooltip","parent","textAccessor","tip","empty","label","text","cord","updateTooltip","xScale","yScale","mouse","graphTransform","xstart","ytop","x_date","invert","tooltipIndex","d","round",5,"load","csv","err","zoomed","xAxisContainer","xAxis","yAxisContainer","yAxis","v","selectAll","j","row","parseFloat","time","format","date_format","parse","xWertebereich","yWertebereich","range","domain","zoom","behavior","scaleExtent","on","graph","w","h","xend","ybottom","circles","enter","this","$","value","points","is","classed","json","res","alert","type","push","scale","axis","orient","ticks","rowName","./modules/line","./modules/range","./modules/sort","./modules/tooltip"],"mappings":"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","file":"script.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Html-Element select zur Auswahl des Modus: Die Variable 'mode' bei\n * Änderung aktualisieren.\n *\n * Checkbox 'Punkte anzeigen': Die Datenpunkte anzeigen / verstecken.\n */\n\nmodule.exports.mode = \"undefined\";\n\n/**\n * Fügt eine Linie hinzu.\n * @param  {[Object]} index  Die Config des Indexes.\n * @param  {[Object]} config Die Config der betreffenden Spalte.\n */\nmodule.exports.addLine = function(index, config, data, accessor_cord) {\n  var path = d3.select(\"#graph\")\n   .append(\"path\")\n   .attr(\"class\", \"line\");\n\n   if(module.exports.mode == \"linear\" || module.exports.mode == \"undefined\"){\n      path.attr(\"d\", module.exports.linear(data, accessor_cord));\n   } else {\n     var line = d3.svg.line()\n       .x(accessor_scaled_x)\n       .y(accessor_scaled_y)\n       .interpolate(module.exports.mode);\n   }\n}\n\n/**\n * Gibt die Lineare Interpolation als SVG-Path-String zurück\n * @param  {[Array]} data        Das Datenarray\n * @param  {{Function}} accessor Die Funktion, welche die Koordinaten zurück-\n *                               gibt des entsprechenden Punktes\n * @return {[String]}            String, das in das Attribut 'd' im path-\n *                               Element eingesetzt werden muss.\n */\nmodule.exports.linear = function(data, accessor) {\n  var path = \"\";\n\n  //figure out\n  var temp = \"Weighted Price\";\n\n  for(var i = 0; i < data.length; i++) {\n    var coordinates = accessor(data[i], temp);\n\n    if(i !== 0){\n      // L-Befehl für eine Linie\n      path += \"L\" + coordinates[0] + \",\" + coordinates[1];\n    } else {\n      // Erster Punkt: M-Befehl für Anfangspunkt.\n      path += \"M\" + coordinates[0] + \",\" + coordinates[1];\n    }\n\n    if(i !== data.length - 1) {\n      path += \" \";\n    }\n  }\n  return path;\n}\n\nmodule.exports.update = function(data, index, values, accessor_cord) {\n  for(var i = 0; i<values.length; i++) {\n    if(module.exports.mode == \"linear\" || module.exports.mode == \"undefined\"){\n      d3.select(\".line\")\n       .attr(\"d\", module.exports.linear(data, accessor_cord));\n    } else {\n      var line = d3.svg.line()\n        .x(index.accessor_scaled)\n        .y(values[i].accessor_scaled)\n        .interpolate(module.exports.mode);\n      d3.select(\".line\")\n        .attr(\"d\", line(data));\n    }\n  }\n\n}\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Html-Element select zur Auswahl des Modus: Die Variable 'mode' bei\n * Änderung aktualisieren.\n *\n * Checkbox 'Punkte anzeigen': Die Datenpunkte anzeigen / verstecken.\n */\n\nmodule.exports.mode = \"undefined\";\n\n/**\n * Fügt eine Linie hinzu.\n * @param  {[Object]} index  Die Config des Indexes.\n * @param  {[Object]} config Die Config der betreffenden Spalte.\n */\nmodule.exports.addLine = function(index, config, data, accessor_cord) {\n  var path = d3.select(\"#graph\")\n   .append(\"path\")\n   .attr(\"class\", \"line\");\n\n   if(module.exports.mode == \"linear\" || module.exports.mode == \"undefined\"){\n      path.attr(\"d\", module.exports.linear(data, accessor_cord));\n   } else {\n     var line = d3.svg.line()\n       .x(accessor_scaled_x)\n       .y(accessor_scaled_y)\n       .interpolate(module.exports.mode);\n   }\n}\n\n/**\n * Gibt die Lineare Interpolation als SVG-Path-String zurück\n * @param  {[Array]} data        Das Datenarray\n * @param  {{Function}} accessor Die Funktion, welche die Koordinaten zurück-\n *                               gibt des entsprechenden Punktes\n * @return {[String]}            String, das in das Attribut 'd' im path-\n *                               Element eingesetzt werden muss.\n */\nmodule.exports.linear = function(data, accessor) {\n  var path = \"\";\n\n  //figure out\n  var temp = \"Weighted Price\";\n\n  for(var i = 0; i < data.length; i++) {\n    var coordinates = accessor(data[i], temp);\n\n    if(i !== 0){\n      // L-Befehl für eine Linie\n      path += \"L\" + coordinates[0] + \",\" + coordinates[1];\n    } else {\n      // Erster Punkt: M-Befehl für Anfangspunkt.\n      path += \"M\" + coordinates[0] + \",\" + coordinates[1];\n    }\n\n    if(i !== data.length - 1) {\n      path += \" \";\n    }\n  }\n  return path;\n}\n\nmodule.exports.update = function(data, index, values, accessor_cord) {\n  for(var i = 0; i<values.length; i++) {\n    if(module.exports.mode == \"linear\" || module.exports.mode == \"undefined\"){\n      d3.select(\".line\")\n       .attr(\"d\", module.exports.linear(data, accessor_cord));\n    } else {\n      var line = d3.svg.line()\n        .x(index.accessor_scaled)\n        .y(values[i].accessor_scaled)\n        .interpolate(module.exports.mode);\n      d3.select(\".line\")\n        .attr(\"d\", line(data));\n    }\n  }\n\n}\n\n},{}],2:[function(require,module,exports){\n/**\n * Gibt das Minimum einer einzelnen Datenreihe zurück\n * @param  {[Array]} data     Der Datensatz\n * @param  {{Function}} index Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}         Das Minimum\n */\nmodule.exports.min = function(data, accessor) {\n  return d3.min(data, accessor);\n}\n\n/**\n * Gibt das Maximum einer einzelnen Datenreihe zurück\n * @param  {[Array]} data     Der Datensatz\n * @param  {{Function}} index Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}         Das Maximum\n */\nmodule.exports.max = function(data, accessor) {\n  return d3.max(data, accessor);\n}\n\n/**\n * Gibt das Minimum für mehrere Datensätze zurück.\n * @param  {[Array]} data   Der Datensatz\n * @param  {[Array]} values Der Config-Array für die zu untersuchenden Datenrei-\n *                          hen.\n * @return {[Object]}       Das Minimum\n */\nmodule.exports.minMultipleSets = function(data, values) {\n  var min;\n  for(var i = 0; i<values.length; i++){\n    var lmin = d3.min(data, values[i].accessor);\n    if(!min || lmin<min) {\n      min = lmin;\n    }\n  }\n  return min;\n}\n\n/**\n * Gibt das Maximum für mehrere Datensätze zurück.\n * @param  {[Array]} data   Der Datensatz\n * @param  {[Array]} values Der Config-Array für die zu untersuchenden Datenrei-\n *                          hen.\n * @return {[Object]}       Das Maximum\n */\nmodule.exports.maxMultipleSets = function(data, values) {\n  var max;\n  for(var i = 0; i<values.length; i++){\n    var lmax = d3.max(data, values[i].accessor);\n    if(!max || lmax>max) {\n      max = lmax;\n    }\n  }\n  return max;\n}\n\n/**\n * Gibt die Summe der Minimums und des mit dem Faktor factor multiplizierten\n * Unterschied von min und max zurück.\n * Wird verwendet, damit oben und rechts von Graphen Platz ausgelassen wird.\n * @param  {[Number]} min       Minimum ohne Overflow\n * @param  {[Number]} max       Maximum ohne Overflow\n * @param  {[Number]} factor    Overflow-Faktor\n * @param  {{String}} data_type Der Datentyp von min und max\n * @return {[Number]}           Das Maximum mit Overflow.\n */\nmodule.exports.applyOverflow = function(min, max, factor, data_type) {\n  if(data_type == \"Date\") {\n    return new Date(min.getTime() + (max.getTime()-min.getTime()) * factor);\n  } else if(data_type == \"Number\") {\n    return min + (max-min) * factor;\n  }\n}\n\n},{}],3:[function(require,module,exports){\n/**\n * Array sortieren\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * @return {[type]} [description]\n */\nmodule.exports = function(data, index) {\n  data.sort(function(a, b) {\n    if (index.accessor(a) < index.accessor(b)) {\n      return -1;\n    }\n    if (index.accessor(a) > index.accessor(b)) {\n      return 1;\n    }\n    return 0;\n  });\n\n  return data;\n}\n\n},{}],4:[function(require,module,exports){\n/*******************************************************************************\n *\n *\n * Tooltip\n *\n *\n ******************************************************************************/\n\nconsole.log(\"Tooltip\");\n\n/**\n * Einstellungen für dieses Modul.\n * @type {Object}\n */\nmodule.exports.opt = {};\n\n/**\n * Findet den zu einem gegebenen Wert den nächsten in einem Array vorhandenem Wert.\n * @param  {[Array]} data         Datenset\n * @param  {[Function]} accessor  Funktion, das den zu vergleichenden Wert\n *                                zurückgibt, wenn das Objekt gegeben wird.\n * @param  {[type]} item          Der zu vergleichende Wert\n * @return {[Number]}             Der Index (0 < @return < data.length-1)\n */\nmodule.exports.nextIndex = function(data, accessor, item){\n  var index = -1;\n  for(var i = 0; i<data.length-1; i++){\n    // Liegt der Punkt zwischen zwei gegebenen Punkten?\n    var this_d = accessor(data[i]);\n    var next = accessor(data[i+1]);\n    var afterThis = item >=this_d;\n    var beforeNext = item <= next;\n\n    if(afterThis && beforeNext){\n      // Falls ja, setze 'index' auf den index des näheren Punktes.\n      Δ1 = Math.abs(accessor(data[i]) - item);\n      Δ2 = Math.abs(accessor(data[i+1]) - item);\n      index = Δ1 < Δ2 ? i : i + 1;\n    }\n  }\n  return index;\n}\n\n/**\n * Funktion für den Tooltip-Kreis und die Werteanzeige\n * @param  {[Array]} data           Datenarray\n * @param  {[Function]} accessor    Funktion, die das Koordinatenpaar den Punktes\n *                                \tzurückgibt.\n * @param  {[Number]} index         Index des Datenarray, die den zu \"tooltippenden\"\n *                                \tWert entspricht.\n * @param {{d3 View}} parent        d3-View, in das das Tooltip eingesetzt werden\n *                    \t\t\t\t\t\t\tsollte.\n * @param {{Function}} textAccessor Funktion, die den Text für das Tooltip zu-\n *                                  rückgibt.\n */\nmodule.exports.tooltip = function(data, accessor, index, parent, textAccessor) {\n  // tooltip-Variablen\n  var tip = d3.select(\"#tooltip\");\n  if(tip.empty()){\n    tip = parent.append(\"g\")\n      .attr(\"id\", \"tooltip\")\n      .attr(\"class\", \"tooltip\");\n\n    tip.append(\"circle\")\n      .attr(\"id\", \"tooltip-circle\");\n\n    var label = tip.append(\"g\")\n      .attr(\"id\", \"label\");\n\n    var text = label.append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"id\", \"label-text\");\n  }\n\n  if(index==-1){\n    tip.attr(\"visibility\", \"hidden\");\n    return;\n  }\n  tip.attr(\"visibility\", \"visible\");\n\n\n  d3.select(\"#label-text\")\n    .text(textAccessor(data[index]))\n    .attr(\"x\", 0)\n    .attr(\"y\", -10);\n\n  var cord = accessor(data[index]);\n  tip.attr(\"transform\", \"translate(\"+cord[0]+\",\"+cord[1]+\")\");\n}\n\n/**\n * Funktion, um den Ort des Tooltips neu zu berechnen (zum Beispiel wenn sich\n * die Maus bewegt oder gezoomt wird).\n * @param  {{Array}}    data        Der Datensatz zu der Visualisation\n * @param  {[d3 Scale]} xScale      Die x-Skala\n * @param  {[d3 Scale]} yScale      Die y-Skala\n * @param  {{Function}} index       Die Config für den Index\n * @param  {{Function}} values      Die Config für die Values\n */\nmodule.exports.updateTooltip = function(data, xScale, yScale, index, values){\n  var cord = [];\n  cord[0] = module.exports.mouse[0]-module.exports.opt.graphTransform.xstart;\n  cord[1] = module.exports.mouse[1]-module.exports.opt.graphTransform.ytop;\n\n  // x|y-Werte berechnen\n  var x_date = xScale.invert(cord[0]);\n\n  for(var i = 0; i<values.length; i++) {\n    //tooltip\n    var tooltipIndex = module.exports.nextIndex(data, index.accessor, x_date);\n\n    //tooltip\n    module.exports.tooltip(data, function(d){\n      return [index.accessor_scaled(d), values[i].accessor_scaled(d)];\n    }, tooltipIndex, d3.select(\"#graph\"), function(d) {\n      // Zahl runden\n      // http://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript\n      return Math.round(values[i].accessor(d) * 1000) / 1000;\n    });\n  }\n}\n\n},{}],5:[function(require,module,exports){\nvar tooltip = require('./modules/tooltip');\nvar line = require('./modules/line');\nvar sort = require('./modules/sort');\nvar range = require('./modules/range');\n\n/*******************************************************************************\n *\n *\n * Initialisierung Visualisation\n *\n *\n ******************************************************************************/\n\n// Für die Visualisation benötigte Variablen\n\nvar config, index, values, xScale, yScale, w, h, graphTransform, mouse,\n  xAxis, yAxis, accessor_cord;\n\n\n/**\n * Laden der Konfigurationsdatei\n * @param  {[String]} \"meta.json\"             Der Dateiname für die\n *                                            Konfigurationsdatei\n * @param  {[Function]} function(err, config) Das Callback\n */\nd3.json(\"meta.json\", function(err, res) {\n  if(err) {\n    console.log(err);\n    alert(err);\n    return;\n  }\n\n  config = res;\n  console.log(config);\n\n  //TODO: 1. Variablen global machen, die für den nächsten Teil benötigt werden✔︎\n  //      2. load() unkommentieren ✔︎\n  //      3. Die config auch wirklich anwenden\n\n  index = {};\n  // Der Array der Datenreihen (Config).\n  values = [];\n\n  for(var i = 0; i<config.length; i++) {\n    if(config[i].type == \"index\"){\n      index = config[i];\n    } else if(config[i].type == \"value\") {\n      values.push(config[i]);\n    }\n  }\n\n  if(index.data_type==\"Number\") {\n    xScale = d3.scale.linear();\n  } else if(index.data_type==\"Date\") {\n    xScale = d3.time.scale();\n  }\n\n  if(values[0].data_type==\"Number\"){\n    yScale = d3.scale.linear();\n  } else if(values[0].data_type==\"Date\") {\n    yScale = d3.time.scale();\n  }\n\n\n\n  // Höhe und Breite des gesamten SVG-Elements definieren; Verschiebung des\n  // Graphs\n  w = 1000;\n  h = 600;\n\n  graphTransform = {xstart: 50, ytop: 0, xend:0, ybottom:50};\n\n  // Das Tooltip über die Transformation benachrichtigen\n  tooltip.opt.graphTransform = graphTransform;\n\n  mouse = [];\n\n  // Wertebereich der Achsenskalierungen definieren. Hier ist die Anzahl der Pixel\n  // gemeint, über die sich die Achsen erstrecken. Die x-Achse und die y-Achse\n  // verschieben wir um 50 nach rechts, damit man die y-Achse beschriften kann.\n  xScale.range([0,w - graphTransform.xstart - graphTransform.xend]);\n  yScale.range([h - graphTransform.ytop - graphTransform.ybottom, 0]);\n\n  // Die Achsen werden von d3 generiert.\n  xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\").ticks(5);\n  yAxis = d3.svg.axis().scale(yScale).orient(\"left\").ticks(5);\n\n  /*******************************************************************************\n   *\n   *\n   * Accessors für die Daten\n   *\n   *\n   ******************************************************************************/\n\n   index.accessor = function(d) {\n     return d[index.row];\n   };\n\n   index.accessor_scaled = function(d) {\n     return xScale(d[index.row]);\n   };\n\n   for(var i = 0; i<values.length; i++){\n     var row = values[i].row;\n     values[i].accessor = function(d) {\n       return d[row];\n     };\n     values[i].accessor_scaled = function(d) {\n       return yScale(d[row]);\n     };\n\n   }\n\n   accessor_cord = function(d, rowName) {\n     return [index.accessor_scaled(d), yScale(d[rowName])];\n   };\n\n   // Die Visualisation laden\n   load();\n});\n\n\n/*******************************************************************************\n *\n *\n * Laden der Daten\n *\n *\n ******************************************************************************/\n\nfunction load() {\n\n  /**\n   * Laden des Datensatzes durch d3, wird in den Array data geladen.\n   * @param  {[String]} 'data.csv'            Pfad der csv-Datei\n   * @param  {[Function]} function(err, data) callback-Funktion, mit Fehlerelement und\n   *                                \t\t\t \t\tDatenarray\n   */\n  d3.csv('data.csv', function(err, data) {\n\n    /**\n     *\n     * Formatieren des Datensatzes\n     *\n     */\n\n    // Sortieren, denn wir brauchen dies für unseren Tooltip-Algorithmus\n    data = sort(data, index);\n\n    // Schleife, um die Einträge zu formatieren: Strings in ein Javascript-\n    // Objekt konvertieren.\n    for(var i = 0; i<data.length; i++) {\n\n      for(var j = 0; j<config.length; j++) {\n        if(config[j].data_type == \"Number\") {\n          data[i][config[j].row] = parseFloat(data[i][config[j].row]);\n        } else if(config[j].data_type == \"Date\") {\n          data[i][config[j].row] =  d3.time.format(config[j].date_format)\n                                      .parse(data[i][config[j].row]);\n        }\n      }\n\n    }\n\n    /**\n     *\n     * d3-Achsen initalisieren\n     *\n     */\n\n    /**\n     *  Wertebereich der Daten bestimmen mit d3: Um einen kleinen Abstand zwischen\n     *  den maximalen Punkten und dem Ende des Rändern des Diagrammes zu bewahren,\n     *  wird der Unterschied (Δ) des Minimums und dem untersuchten Wert mit 1.1\n     *  mulitpliziert. Anschliessend wird die Summe des Minimums und des\n     *  multiplizierten Wertes an d3 zurückgegeben.\n     */\n    var xWertebereich = [];\n    var yWertebereich = [];\n\n    xWertebereich[0] = range.min(data, index.accessor);\n    xWertebereich[1] = range.max(data, index.accessor);\n\n    yWertebereich[0] = range.minMultipleSets(data, values);\n    yWertebereich[1] = range.maxMultipleSets(data, values);\n\n    xWertebereich[1] = range.applyOverflow(xWertebereich[0], xWertebereich[1],\n      1.1, index.data_type);\n    yWertebereich[1] = range.applyOverflow(yWertebereich[0], yWertebereich[1],\n      1.1, values[0].data_type);\n\n    xScale.domain(xWertebereich);\n    yScale.domain(yWertebereich);\n\n    /**\n     *\n     * Zoom\n     *\n     */\n\n    // Zoom hinzufügen, das durch d3 unterstützt wird\n    var zoom = d3.behavior.zoom()\n      .x(xScale)\n      .y(yScale)\n      .scaleExtent([1, 50])\n      .on(\"zoom\", zoomed);\n\n    // die variable graph initialiseren, damit sie in der Funktion zoomed() ver-\n    // wendet werden kann, obwohl sie erst später definiert wird.\n    var graph = null;\n\n    // Mit der Funktion 'zoomed' werden die x-Achse und die y-Achse aktualisiert\n    function zoomed() {\n      // Achsen neu zeichnen\n      xAxisContainer.call(xAxis);\n      yAxisContainer.call(yAxis);\n\n      // Punkte neu berechnen.\n      for(var i = 0; i<values.length; i++) {\n        v.selectAll(\"circle.data-point\")\n          .attr(\"cx\", index.accessor_scaled)\n          .attr(\"cy\", values[i].accessor_scaled);\n      }\n\n      // Tooltip bei Zoom auch aktualisieren\n      tooltip.updateTooltip(data, xScale, yScale, index, values);\n\n      // Linie bei Zoom aktualisieren\n      line.update(data, index, values, accessor_cord);\n    }\n\n    /**\n     *\n     * (Datengebundene) Elemente einfügen\n     *\n     */\n\n    // SVG-Element mit id 'visualization' extrahieren\n    var v = d3.select(\"#visualization\")\n      .attr(\"width\", w)\n      .attr(\"height\", h)\n\n    // Unterstützung für Zoom hinzufügen (d3)\n      .call(zoom);\n\n    // SVG-Maske für den Graph: Wir wollen nicht, dass Punkte aus unserem\n    // definierten Feld auftauchen.\n    v.append(\"mask\")\n      .attr(\"id\", \"mask\")\n      .append(\"rect\")\n        .attr(\"x\", 0)\n        .attr(\"y\", 0)\n        .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n        .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n        .attr(\"fill\", \"white\");\n\n    graph = v.append(\"g\")\n      .attr(\"id\", \"graph\")\n      .attr(\"transform\", \"translate(\" + graphTransform.xstart +\n        \",\" + graphTransform.ytop + \")\")\n      .attr(\"mask\", \"url(#mask)\");\n\n    // Die Daten zum Element mit der d3-Binding-Method binden: Die nach dem\n    // enter() stehenden Befehle werden für alle Elemente in dem Array\n    // ausgeführt.\n    var circles = graph.selectAll(\"circle\")\n      .data(data).enter();\n\n    for(var i = 0; i<values.length; i++) {\n      circles.append(\"circle\")\n          .attr(\"class\", \"data-point\")\n          //TODO: add here attribute data-row and add support in the whole code\n          // for this.\n          .attr(\"cx\", index.accessor_scaled)\n          .attr(\"cy\", values[i].accessor_scaled);\n    }\n\n    /**\n     *\n     * d3-Achsen einfügen\n     *\n     */\n\n    // Achsen hinzufügen\n    var xAxisContainer = v.append(\"g\")\n      .attr(\"class\", \"axis axis-x\")\n      .attr(\"transform\", \"translate(\" +\n        graphTransform.xstart + \",\" +\n        (h - graphTransform.ybottom) + \")\")\n      .call(xAxis);\n\n    var yAxisContainer = v.append(\"g\")\n      .attr(\"class\", \"axis axis-y\")\n      .attr(\"transform\", \"translate(50,0)\")\n      .call(yAxis);\n\n    /**\n     *\n     * Tooltip (nicht von d3)\n     *\n     */\n\n    // Maus-Koordinaten: Um auf die Maus-Koordinaten zugreifen zu können, muss man\n    // ein unsichtbares Element über den gesamten Graph legen, der alle\n    // 'Maus-Events' \"aufnimmt\". Ein leerer g-SVG-Container (wie 'graph') ist\n    // nicht fähig, Maus-Events aufzunehmen.\n    v.append(\"rect\")\n      .attr(\"id\", \"overlay\")\n      .attr(\"x\", graphTransform.xstart)\n      .attr(\"y\", graphTransform.ytop)\n      .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n      .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n      .on(\"mousemove\", function() {\n        tooltip.mouse = d3.mouse(this);\n        tooltip.updateTooltip(data, xScale, yScale, index, values);\n      });\n\n    /**\n     *\n     * Linien\n     *\n     */\n\n     for(var i = 0; i<values.length; i++) {\n        line.addLine(index, values[i], data, accessor_cord);\n     }\n\n     $('select').on('change', function() {\n       line.mode = this.value;\n       line.update(data, index, values, accessor_cord);\n     });\n\n     $('#checkbox').on('change', function() {\n       var points = d3.selectAll(\".data-point\");\n       if(!$(this).is(\":checked\")){\n         points.classed(\"hidden\", true);\n       } else {\n         points.classed(\"hidden\", false);\n       }\n     });\n\n  });\n}\n\n},{\"./modules/line\":1,\"./modules/range\":2,\"./modules/sort\":3,\"./modules/tooltip\":4}]},{},[5])\n\n","/**\n * Gibt das Minimum einer einzelnen Datenreihe zurück\n * @param  {[Array]} data     Der Datensatz\n * @param  {{Function}} index Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}         Das Minimum\n */\nmodule.exports.min = function(data, accessor) {\n  return d3.min(data, accessor);\n}\n\n/**\n * Gibt das Maximum einer einzelnen Datenreihe zurück\n * @param  {[Array]} data     Der Datensatz\n * @param  {{Function}} index Der Accessor für die zu untersuchende Datenreihe\n * @return {[Object]}         Das Maximum\n */\nmodule.exports.max = function(data, accessor) {\n  return d3.max(data, accessor);\n}\n\n/**\n * Gibt das Minimum für mehrere Datensätze zurück.\n * @param  {[Array]} data   Der Datensatz\n * @param  {[Array]} values Der Config-Array für die zu untersuchenden Datenrei-\n *                          hen.\n * @return {[Object]}       Das Minimum\n */\nmodule.exports.minMultipleSets = function(data, values) {\n  var min;\n  for(var i = 0; i<values.length; i++){\n    var lmin = d3.min(data, values[i].accessor);\n    if(!min || lmin<min) {\n      min = lmin;\n    }\n  }\n  return min;\n}\n\n/**\n * Gibt das Maximum für mehrere Datensätze zurück.\n * @param  {[Array]} data   Der Datensatz\n * @param  {[Array]} values Der Config-Array für die zu untersuchenden Datenrei-\n *                          hen.\n * @return {[Object]}       Das Maximum\n */\nmodule.exports.maxMultipleSets = function(data, values) {\n  var max;\n  for(var i = 0; i<values.length; i++){\n    var lmax = d3.max(data, values[i].accessor);\n    if(!max || lmax>max) {\n      max = lmax;\n    }\n  }\n  return max;\n}\n\n/**\n * Gibt die Summe der Minimums und des mit dem Faktor factor multiplizierten\n * Unterschied von min und max zurück.\n * Wird verwendet, damit oben und rechts von Graphen Platz ausgelassen wird.\n * @param  {[Number]} min       Minimum ohne Overflow\n * @param  {[Number]} max       Maximum ohne Overflow\n * @param  {[Number]} factor    Overflow-Faktor\n * @param  {{String}} data_type Der Datentyp von min und max\n * @return {[Number]}           Das Maximum mit Overflow.\n */\nmodule.exports.applyOverflow = function(min, max, factor, data_type) {\n  if(data_type == \"Date\") {\n    return new Date(min.getTime() + (max.getTime()-min.getTime()) * factor);\n  } else if(data_type == \"Number\") {\n    return min + (max-min) * factor;\n  }\n}\n","/**\n * Array sortieren\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * @return {[type]} [description]\n */\nmodule.exports = function(data, index) {\n  data.sort(function(a, b) {\n    if (index.accessor(a) < index.accessor(b)) {\n      return -1;\n    }\n    if (index.accessor(a) > index.accessor(b)) {\n      return 1;\n    }\n    return 0;\n  });\n\n  return data;\n}\n","/*******************************************************************************\n *\n *\n * Tooltip\n *\n *\n ******************************************************************************/\n\nconsole.log(\"Tooltip\");\n\n/**\n * Einstellungen für dieses Modul.\n * @type {Object}\n */\nmodule.exports.opt = {};\n\n/**\n * Findet den zu einem gegebenen Wert den nächsten in einem Array vorhandenem Wert.\n * @param  {[Array]} data         Datenset\n * @param  {[Function]} accessor  Funktion, das den zu vergleichenden Wert\n *                                zurückgibt, wenn das Objekt gegeben wird.\n * @param  {[type]} item          Der zu vergleichende Wert\n * @return {[Number]}             Der Index (0 < @return < data.length-1)\n */\nmodule.exports.nextIndex = function(data, accessor, item){\n  var index = -1;\n  for(var i = 0; i<data.length-1; i++){\n    // Liegt der Punkt zwischen zwei gegebenen Punkten?\n    var this_d = accessor(data[i]);\n    var next = accessor(data[i+1]);\n    var afterThis = item >=this_d;\n    var beforeNext = item <= next;\n\n    if(afterThis && beforeNext){\n      // Falls ja, setze 'index' auf den index des näheren Punktes.\n      Δ1 = Math.abs(accessor(data[i]) - item);\n      Δ2 = Math.abs(accessor(data[i+1]) - item);\n      index = Δ1 < Δ2 ? i : i + 1;\n    }\n  }\n  return index;\n}\n\n/**\n * Funktion für den Tooltip-Kreis und die Werteanzeige\n * @param  {[Array]} data           Datenarray\n * @param  {[Function]} accessor    Funktion, die das Koordinatenpaar den Punktes\n *                                \tzurückgibt.\n * @param  {[Number]} index         Index des Datenarray, die den zu \"tooltippenden\"\n *                                \tWert entspricht.\n * @param {{d3 View}} parent        d3-View, in das das Tooltip eingesetzt werden\n *                    \t\t\t\t\t\t\tsollte.\n * @param {{Function}} textAccessor Funktion, die den Text für das Tooltip zu-\n *                                  rückgibt.\n */\nmodule.exports.tooltip = function(data, accessor, index, parent, textAccessor) {\n  // tooltip-Variablen\n  var tip = d3.select(\"#tooltip\");\n  if(tip.empty()){\n    tip = parent.append(\"g\")\n      .attr(\"id\", \"tooltip\")\n      .attr(\"class\", \"tooltip\");\n\n    tip.append(\"circle\")\n      .attr(\"id\", \"tooltip-circle\");\n\n    var label = tip.append(\"g\")\n      .attr(\"id\", \"label\");\n\n    var text = label.append(\"text\")\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"id\", \"label-text\");\n  }\n\n  if(index==-1){\n    tip.attr(\"visibility\", \"hidden\");\n    return;\n  }\n  tip.attr(\"visibility\", \"visible\");\n\n\n  d3.select(\"#label-text\")\n    .text(textAccessor(data[index]))\n    .attr(\"x\", 0)\n    .attr(\"y\", -10);\n\n  var cord = accessor(data[index]);\n  tip.attr(\"transform\", \"translate(\"+cord[0]+\",\"+cord[1]+\")\");\n}\n\n/**\n * Funktion, um den Ort des Tooltips neu zu berechnen (zum Beispiel wenn sich\n * die Maus bewegt oder gezoomt wird).\n * @param  {{Array}}    data        Der Datensatz zu der Visualisation\n * @param  {[d3 Scale]} xScale      Die x-Skala\n * @param  {[d3 Scale]} yScale      Die y-Skala\n * @param  {{Function}} index       Die Config für den Index\n * @param  {{Function}} values      Die Config für die Values\n */\nmodule.exports.updateTooltip = function(data, xScale, yScale, index, values){\n  var cord = [];\n  cord[0] = module.exports.mouse[0]-module.exports.opt.graphTransform.xstart;\n  cord[1] = module.exports.mouse[1]-module.exports.opt.graphTransform.ytop;\n\n  // x|y-Werte berechnen\n  var x_date = xScale.invert(cord[0]);\n\n  for(var i = 0; i<values.length; i++) {\n    //tooltip\n    var tooltipIndex = module.exports.nextIndex(data, index.accessor, x_date);\n\n    //tooltip\n    module.exports.tooltip(data, function(d){\n      return [index.accessor_scaled(d), values[i].accessor_scaled(d)];\n    }, tooltipIndex, d3.select(\"#graph\"), function(d) {\n      // Zahl runden\n      // http://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript\n      return Math.round(values[i].accessor(d) * 1000) / 1000;\n    });\n  }\n}\n","var tooltip = require('./modules/tooltip');\nvar line = require('./modules/line');\nvar sort = require('./modules/sort');\nvar range = require('./modules/range');\n\n/*******************************************************************************\n *\n *\n * Initialisierung Visualisation\n *\n *\n ******************************************************************************/\n\n// Für die Visualisation benötigte Variablen\n\nvar config, index, values, xScale, yScale, w, h, graphTransform, mouse,\n  xAxis, yAxis, accessor_cord;\n\n\n/**\n * Laden der Konfigurationsdatei\n * @param  {[String]} \"meta.json\"             Der Dateiname für die\n *                                            Konfigurationsdatei\n * @param  {[Function]} function(err, config) Das Callback\n */\nd3.json(\"meta.json\", function(err, res) {\n  if(err) {\n    console.log(err);\n    alert(err);\n    return;\n  }\n\n  config = res;\n  console.log(config);\n\n  //TODO: 1. Variablen global machen, die für den nächsten Teil benötigt werden✔︎\n  //      2. load() unkommentieren ✔︎\n  //      3. Die config auch wirklich anwenden\n\n  index = {};\n  // Der Array der Datenreihen (Config).\n  values = [];\n\n  for(var i = 0; i<config.length; i++) {\n    if(config[i].type == \"index\"){\n      index = config[i];\n    } else if(config[i].type == \"value\") {\n      values.push(config[i]);\n    }\n  }\n\n  if(index.data_type==\"Number\") {\n    xScale = d3.scale.linear();\n  } else if(index.data_type==\"Date\") {\n    xScale = d3.time.scale();\n  }\n\n  if(values[0].data_type==\"Number\"){\n    yScale = d3.scale.linear();\n  } else if(values[0].data_type==\"Date\") {\n    yScale = d3.time.scale();\n  }\n\n\n\n  // Höhe und Breite des gesamten SVG-Elements definieren; Verschiebung des\n  // Graphs\n  w = 1000;\n  h = 600;\n\n  graphTransform = {xstart: 50, ytop: 0, xend:0, ybottom:50};\n\n  // Das Tooltip über die Transformation benachrichtigen\n  tooltip.opt.graphTransform = graphTransform;\n\n  mouse = [];\n\n  // Wertebereich der Achsenskalierungen definieren. Hier ist die Anzahl der Pixel\n  // gemeint, über die sich die Achsen erstrecken. Die x-Achse und die y-Achse\n  // verschieben wir um 50 nach rechts, damit man die y-Achse beschriften kann.\n  xScale.range([0,w - graphTransform.xstart - graphTransform.xend]);\n  yScale.range([h - graphTransform.ytop - graphTransform.ybottom, 0]);\n\n  // Die Achsen werden von d3 generiert.\n  xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\").ticks(5);\n  yAxis = d3.svg.axis().scale(yScale).orient(\"left\").ticks(5);\n\n  /*******************************************************************************\n   *\n   *\n   * Accessors für die Daten\n   *\n   *\n   ******************************************************************************/\n\n   index.accessor = function(d) {\n     return d[index.row];\n   };\n\n   index.accessor_scaled = function(d) {\n     return xScale(d[index.row]);\n   };\n\n   for(var i = 0; i<values.length; i++){\n     var row = values[i].row;\n     values[i].accessor = function(d) {\n       return d[row];\n     };\n     values[i].accessor_scaled = function(d) {\n       return yScale(d[row]);\n     };\n\n   }\n\n   accessor_cord = function(d, rowName) {\n     return [index.accessor_scaled(d), yScale(d[rowName])];\n   };\n\n   // Die Visualisation laden\n   load();\n});\n\n\n/*******************************************************************************\n *\n *\n * Laden der Daten\n *\n *\n ******************************************************************************/\n\nfunction load() {\n\n  /**\n   * Laden des Datensatzes durch d3, wird in den Array data geladen.\n   * @param  {[String]} 'data.csv'            Pfad der csv-Datei\n   * @param  {[Function]} function(err, data) callback-Funktion, mit Fehlerelement und\n   *                                \t\t\t \t\tDatenarray\n   */\n  d3.csv('data.csv', function(err, data) {\n\n    /**\n     *\n     * Formatieren des Datensatzes\n     *\n     */\n\n    // Sortieren, denn wir brauchen dies für unseren Tooltip-Algorithmus\n    data = sort(data, index);\n\n    // Schleife, um die Einträge zu formatieren: Strings in ein Javascript-\n    // Objekt konvertieren.\n    for(var i = 0; i<data.length; i++) {\n\n      for(var j = 0; j<config.length; j++) {\n        if(config[j].data_type == \"Number\") {\n          data[i][config[j].row] = parseFloat(data[i][config[j].row]);\n        } else if(config[j].data_type == \"Date\") {\n          data[i][config[j].row] =  d3.time.format(config[j].date_format)\n                                      .parse(data[i][config[j].row]);\n        }\n      }\n\n    }\n\n    /**\n     *\n     * d3-Achsen initalisieren\n     *\n     */\n\n    /**\n     *  Wertebereich der Daten bestimmen mit d3: Um einen kleinen Abstand zwischen\n     *  den maximalen Punkten und dem Ende des Rändern des Diagrammes zu bewahren,\n     *  wird der Unterschied (Δ) des Minimums und dem untersuchten Wert mit 1.1\n     *  mulitpliziert. Anschliessend wird die Summe des Minimums und des\n     *  multiplizierten Wertes an d3 zurückgegeben.\n     */\n    var xWertebereich = [];\n    var yWertebereich = [];\n\n    xWertebereich[0] = range.min(data, index.accessor);\n    xWertebereich[1] = range.max(data, index.accessor);\n\n    yWertebereich[0] = range.minMultipleSets(data, values);\n    yWertebereich[1] = range.maxMultipleSets(data, values);\n\n    xWertebereich[1] = range.applyOverflow(xWertebereich[0], xWertebereich[1],\n      1.1, index.data_type);\n    yWertebereich[1] = range.applyOverflow(yWertebereich[0], yWertebereich[1],\n      1.1, values[0].data_type);\n\n    xScale.domain(xWertebereich);\n    yScale.domain(yWertebereich);\n\n    /**\n     *\n     * Zoom\n     *\n     */\n\n    // Zoom hinzufügen, das durch d3 unterstützt wird\n    var zoom = d3.behavior.zoom()\n      .x(xScale)\n      .y(yScale)\n      .scaleExtent([1, 50])\n      .on(\"zoom\", zoomed);\n\n    // die variable graph initialiseren, damit sie in der Funktion zoomed() ver-\n    // wendet werden kann, obwohl sie erst später definiert wird.\n    var graph = null;\n\n    // Mit der Funktion 'zoomed' werden die x-Achse und die y-Achse aktualisiert\n    function zoomed() {\n      // Achsen neu zeichnen\n      xAxisContainer.call(xAxis);\n      yAxisContainer.call(yAxis);\n\n      // Punkte neu berechnen.\n      for(var i = 0; i<values.length; i++) {\n        v.selectAll(\"circle.data-point\")\n          .attr(\"cx\", index.accessor_scaled)\n          .attr(\"cy\", values[i].accessor_scaled);\n      }\n\n      // Tooltip bei Zoom auch aktualisieren\n      tooltip.updateTooltip(data, xScale, yScale, index, values);\n\n      // Linie bei Zoom aktualisieren\n      line.update(data, index, values, accessor_cord);\n    }\n\n    /**\n     *\n     * (Datengebundene) Elemente einfügen\n     *\n     */\n\n    // SVG-Element mit id 'visualization' extrahieren\n    var v = d3.select(\"#visualization\")\n      .attr(\"width\", w)\n      .attr(\"height\", h)\n\n    // Unterstützung für Zoom hinzufügen (d3)\n      .call(zoom);\n\n    // SVG-Maske für den Graph: Wir wollen nicht, dass Punkte aus unserem\n    // definierten Feld auftauchen.\n    v.append(\"mask\")\n      .attr(\"id\", \"mask\")\n      .append(\"rect\")\n        .attr(\"x\", 0)\n        .attr(\"y\", 0)\n        .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n        .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n        .attr(\"fill\", \"white\");\n\n    graph = v.append(\"g\")\n      .attr(\"id\", \"graph\")\n      .attr(\"transform\", \"translate(\" + graphTransform.xstart +\n        \",\" + graphTransform.ytop + \")\")\n      .attr(\"mask\", \"url(#mask)\");\n\n    // Die Daten zum Element mit der d3-Binding-Method binden: Die nach dem\n    // enter() stehenden Befehle werden für alle Elemente in dem Array\n    // ausgeführt.\n    var circles = graph.selectAll(\"circle\")\n      .data(data).enter();\n\n    for(var i = 0; i<values.length; i++) {\n      circles.append(\"circle\")\n          .attr(\"class\", \"data-point\")\n          //TODO: add here attribute data-row and add support in the whole code\n          // for this.\n          .attr(\"cx\", index.accessor_scaled)\n          .attr(\"cy\", values[i].accessor_scaled);\n    }\n\n    /**\n     *\n     * d3-Achsen einfügen\n     *\n     */\n\n    // Achsen hinzufügen\n    var xAxisContainer = v.append(\"g\")\n      .attr(\"class\", \"axis axis-x\")\n      .attr(\"transform\", \"translate(\" +\n        graphTransform.xstart + \",\" +\n        (h - graphTransform.ybottom) + \")\")\n      .call(xAxis);\n\n    var yAxisContainer = v.append(\"g\")\n      .attr(\"class\", \"axis axis-y\")\n      .attr(\"transform\", \"translate(50,0)\")\n      .call(yAxis);\n\n    /**\n     *\n     * Tooltip (nicht von d3)\n     *\n     */\n\n    // Maus-Koordinaten: Um auf die Maus-Koordinaten zugreifen zu können, muss man\n    // ein unsichtbares Element über den gesamten Graph legen, der alle\n    // 'Maus-Events' \"aufnimmt\". Ein leerer g-SVG-Container (wie 'graph') ist\n    // nicht fähig, Maus-Events aufzunehmen.\n    v.append(\"rect\")\n      .attr(\"id\", \"overlay\")\n      .attr(\"x\", graphTransform.xstart)\n      .attr(\"y\", graphTransform.ytop)\n      .attr(\"width\", w - graphTransform.xstart - graphTransform.xend)\n      .attr(\"height\", h - graphTransform.ytop - graphTransform.ybottom)\n      .on(\"mousemove\", function() {\n        tooltip.mouse = d3.mouse(this);\n        tooltip.updateTooltip(data, xScale, yScale, index, values);\n      });\n\n    /**\n     *\n     * Linien\n     *\n     */\n\n     for(var i = 0; i<values.length; i++) {\n        line.addLine(index, values[i], data, accessor_cord);\n     }\n\n     $('select').on('change', function() {\n       line.mode = this.value;\n       line.update(data, index, values, accessor_cord);\n     });\n\n     $('#checkbox').on('change', function() {\n       var points = d3.selectAll(\".data-point\");\n       if(!$(this).is(\":checked\")){\n         points.classed(\"hidden\", true);\n       } else {\n         points.classed(\"hidden\", false);\n       }\n     });\n\n  });\n}\n"],"sourceRoot":"/source/"}